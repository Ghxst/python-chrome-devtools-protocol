'''
DO NOT EDIT THIS FILE

This file is generated from the CDP definitions. If you need to make changes,
edit the generator and regenerate all of the modules.

Domain: css
Experimental: True
'''

from dataclasses import dataclass, field
import typing

from ..dom import types as dom
from ..page import types as page


class StyleSheetId(str):
    @classmethod
    def from_response(cls, response):
        return cls(response)

    def __repr__(self):
        return 'StyleSheetId({})'.format(str.__repr__(self))



class StyleSheetOrigin:
    '''
    Stylesheet type: "injected" for stylesheets injected via extension, "user-agent" for user-agent
    stylesheets, "inspector" for stylesheets created by the inspector (i.e. those holding the "via
    inspector" rules), "regular" for regular stylesheets.
    '''
    INJECTED = "injected"
    USER_AGENT = "user-agent"
    INSPECTOR = "inspector"
    REGULAR = "regular"


@dataclass
class PseudoElementMatches:
    '''
    CSS rule collection for a single pseudo style.
    '''
    #: Pseudo element type.
    pseudo_type: dom.PseudoType

    #: Matches of CSS rules applicable to the pseudo style.
    matches: typing.List['RuleMatch']

    @classmethod
    def from_response(cls, response):
        return cls(
            pseudo_type=dom.PseudoType.from_response(response.get('pseudoType')),
            matches=[RuleMatch.from_response(i) for i in response.get('matches')],
        )


@dataclass
class SelectorList:
    '''
    Selector list data.
    '''
    #: Selectors in the list.
    selectors: typing.List['Value']

    #: Rule selector text.
    text: str

    @classmethod
    def from_response(cls, response):
        return cls(
            selectors=[Value.from_response(i) for i in response.get('selectors')],
            text=str(response.get('text')),
        )


@dataclass
class CSSStyleSheetHeader:
    '''
    CSS stylesheet metainformation.
    '''
    #: The stylesheet identifier.
    style_sheet_id: StyleSheetId

    #: Owner frame identifier.
    frame_id: page.FrameId

    #: Stylesheet resource URL.
    source_url: str

    #: URL of source map associated with the stylesheet (if any).
    source_map_url: str

    #: Stylesheet origin.
    origin: StyleSheetOrigin

    #: Stylesheet title.
    title: str

    #: The backend id for the owner node of the stylesheet.
    owner_node: dom.BackendNodeId

    #: Denotes whether the stylesheet is disabled.
    disabled: bool

    #: Whether the sourceURL field value comes from the sourceURL comment.
    has_source_url: bool

    #: Whether this stylesheet is created for STYLE tag by parser. This flag is not set for
    #: document.written STYLE tags.
    is_inline: bool

    #: Line offset of the stylesheet within the resource (zero based).
    start_line: float

    #: Column offset of the stylesheet within the resource (zero based).
    start_column: float

    #: Size of the content (in characters).
    length: float

    @classmethod
    def from_response(cls, response):
        return cls(
            style_sheet_id=StyleSheetId.from_response(response.get('styleSheetId')),
            frame_id=page.FrameId.from_response(response.get('frameId')),
            source_url=str(response.get('sourceURL')),
            source_map_url=str(response.get('sourceMapURL')),
            origin=StyleSheetOrigin.from_response(response.get('origin')),
            title=str(response.get('title')),
            owner_node=dom.BackendNodeId.from_response(response.get('ownerNode')),
            disabled=bool(response.get('disabled')),
            has_source_url=bool(response.get('hasSourceURL')),
            is_inline=bool(response.get('isInline')),
            start_line=float(response.get('startLine')),
            start_column=float(response.get('startColumn')),
            length=float(response.get('length')),
        )


@dataclass
class RuleUsage:
    '''
    CSS coverage information.
    '''
    #: The css style sheet identifier (absent for user agent stylesheet and user-specified
    #: stylesheet rules) this rule came from.
    style_sheet_id: StyleSheetId

    #: Offset of the start of the rule (including selector) from the beginning of the stylesheet.
    start_offset: float

    #: Offset of the end of the rule body from the beginning of the stylesheet.
    end_offset: float

    #: Indicates whether the rule was actually used by some element in the page.
    used: bool

    @classmethod
    def from_response(cls, response):
        return cls(
            style_sheet_id=StyleSheetId.from_response(response.get('styleSheetId')),
            start_offset=float(response.get('startOffset')),
            end_offset=float(response.get('endOffset')),
            used=bool(response.get('used')),
        )


@dataclass
class SourceRange:
    '''
    Text range within a resource. All numbers are zero-based.
    '''
    #: Start line of range.
    start_line: int

    #: Start column of range (inclusive).
    start_column: int

    #: End line of range
    end_line: int

    #: End column of range (exclusive).
    end_column: int

    @classmethod
    def from_response(cls, response):
        return cls(
            start_line=int(response.get('startLine')),
            start_column=int(response.get('startColumn')),
            end_line=int(response.get('endLine')),
            end_column=int(response.get('endColumn')),
        )


@dataclass
class ShorthandEntry:
    #: Shorthand name.
    name: str

    #: Shorthand value.
    value: str

    #: Whether the property has "!important" annotation (implies `false` if absent).
    important: bool

    @classmethod
    def from_response(cls, response):
        return cls(
            name=str(response.get('name')),
            value=str(response.get('value')),
            important=bool(response.get('important')),
        )


@dataclass
class CSSComputedStyleProperty:
    #: Computed style property name.
    name: str

    #: Computed style property value.
    value: str

    @classmethod
    def from_response(cls, response):
        return cls(
            name=str(response.get('name')),
            value=str(response.get('value')),
        )


@dataclass
class CSSStyle:
    '''
    CSS style representation.
    '''
    #: The css style sheet identifier (absent for user agent stylesheet and user-specified
    #: stylesheet rules) this rule came from.
    style_sheet_id: StyleSheetId

    #: CSS properties in the style.
    css_properties: typing.List['CSSProperty']

    #: Computed values for all shorthands found in the style.
    shorthand_entries: typing.List['ShorthandEntry']

    #: Style declaration text (if available).
    css_text: str

    #: Style declaration range in the enclosing stylesheet (if available).
    range: SourceRange

    @classmethod
    def from_response(cls, response):
        return cls(
            style_sheet_id=StyleSheetId.from_response(response.get('styleSheetId')),
            css_properties=[CSSProperty.from_response(i) for i in response.get('cssProperties')],
            shorthand_entries=[ShorthandEntry.from_response(i) for i in response.get('shorthandEntries')],
            css_text=str(response.get('cssText')),
            range=SourceRange.from_response(response.get('range')),
        )


@dataclass
class CSSProperty:
    '''
    CSS property declaration data.
    '''
    #: The property name.
    name: str

    #: The property value.
    value: str

    #: Whether the property has "!important" annotation (implies `false` if absent).
    important: bool

    #: Whether the property is implicit (implies `false` if absent).
    implicit: bool

    #: The full property text as specified in the style.
    text: str

    #: Whether the property is understood by the browser (implies `true` if absent).
    parsed_ok: bool

    #: Whether the property is disabled by the user (present for source-based properties only).
    disabled: bool

    #: The entire property range in the enclosing style declaration (if available).
    range: SourceRange

    @classmethod
    def from_response(cls, response):
        return cls(
            name=str(response.get('name')),
            value=str(response.get('value')),
            important=bool(response.get('important')),
            implicit=bool(response.get('implicit')),
            text=str(response.get('text')),
            parsed_ok=bool(response.get('parsedOk')),
            disabled=bool(response.get('disabled')),
            range=SourceRange.from_response(response.get('range')),
        )


@dataclass
class CSSMedia:
    '''
    CSS media rule descriptor.
    '''
    #: Media query text.
    text: str

    #: Source of the media query: "mediaRule" if specified by a @media rule, "importRule" if
    #: specified by an @import rule, "linkedSheet" if specified by a "media" attribute in a linked
    #: stylesheet's LINK tag, "inlineSheet" if specified by a "media" attribute in an inline
    #: stylesheet's STYLE tag.
    source: str

    #: URL of the document containing the media query description.
    source_url: str

    #: The associated rule (@media or @import) header range in the enclosing stylesheet (if
    #: available).
    range: SourceRange

    #: Identifier of the stylesheet containing this object (if exists).
    style_sheet_id: StyleSheetId

    #: Array of media queries.
    media_list: typing.List['MediaQuery']

    @classmethod
    def from_response(cls, response):
        return cls(
            text=str(response.get('text')),
            source=str(response.get('source')),
            source_url=str(response.get('sourceURL')),
            range=SourceRange.from_response(response.get('range')),
            style_sheet_id=StyleSheetId.from_response(response.get('styleSheetId')),
            media_list=[MediaQuery.from_response(i) for i in response.get('mediaList')],
        )


@dataclass
class MediaQuery:
    '''
    Media query descriptor.
    '''
    #: Array of media query expressions.
    expressions: typing.List['MediaQueryExpression']

    #: Whether the media query condition is satisfied.
    active: bool

    @classmethod
    def from_response(cls, response):
        return cls(
            expressions=[MediaQueryExpression.from_response(i) for i in response.get('expressions')],
            active=bool(response.get('active')),
        )


@dataclass
class MediaQueryExpression:
    '''
    Media query expression descriptor.
    '''
    #: Media query expression value.
    value: float

    #: Media query expression units.
    unit: str

    #: Media query expression feature.
    feature: str

    #: The associated range of the value text in the enclosing stylesheet (if available).
    value_range: SourceRange

    #: Computed length of media query expression (if applicable).
    computed_length: float

    @classmethod
    def from_response(cls, response):
        return cls(
            value=float(response.get('value')),
            unit=str(response.get('unit')),
            feature=str(response.get('feature')),
            value_range=SourceRange.from_response(response.get('valueRange')),
            computed_length=float(response.get('computedLength')),
        )


@dataclass
class PlatformFontUsage:
    '''
    Information about amount of glyphs that were rendered with given font.
    '''
    #: Font's family name reported by platform.
    family_name: str

    #: Indicates if the font was downloaded or resolved locally.
    is_custom_font: bool

    #: Amount of glyphs that were rendered with this font.
    glyph_count: float

    @classmethod
    def from_response(cls, response):
        return cls(
            family_name=str(response.get('familyName')),
            is_custom_font=bool(response.get('isCustomFont')),
            glyph_count=float(response.get('glyphCount')),
        )


@dataclass
class FontFace:
    '''
    Properties of a web font: https://www.w3.org/TR/2008/REC-CSS2-20080411/fonts.html#font-descriptions
    '''
    #: The font-family.
    font_family: str

    #: The font-style.
    font_style: str

    #: The font-variant.
    font_variant: str

    #: The font-weight.
    font_weight: str

    #: The font-stretch.
    font_stretch: str

    #: The unicode-range.
    unicode_range: str

    #: The src.
    src: str

    #: The resolved platform font family
    platform_font_family: str

    @classmethod
    def from_response(cls, response):
        return cls(
            font_family=str(response.get('fontFamily')),
            font_style=str(response.get('fontStyle')),
            font_variant=str(response.get('fontVariant')),
            font_weight=str(response.get('fontWeight')),
            font_stretch=str(response.get('fontStretch')),
            unicode_range=str(response.get('unicodeRange')),
            src=str(response.get('src')),
            platform_font_family=str(response.get('platformFontFamily')),
        )


@dataclass
class StyleDeclarationEdit:
    '''
    A descriptor of operation to mutate style declaration text.
    '''
    #: The css style sheet identifier.
    style_sheet_id: StyleSheetId

    #: The range of the style text in the enclosing stylesheet.
    range: SourceRange

    #: New style text.
    text: str

    @classmethod
    def from_response(cls, response):
        return cls(
            style_sheet_id=StyleSheetId.from_response(response.get('styleSheetId')),
            range=SourceRange.from_response(response.get('range')),
            text=str(response.get('text')),
        )


@dataclass
class InheritedStyleEntry:
    '''
    Inherited CSS rule collection from ancestor node.
    '''
    #: The ancestor node's inline style, if any, in the style inheritance chain.
    inline_style: CSSStyle

    #: Matches of CSS rules matching the ancestor node in the style inheritance chain.
    matched_css_rules: typing.List['RuleMatch']

    @classmethod
    def from_response(cls, response):
        return cls(
            inline_style=CSSStyle.from_response(response.get('inlineStyle')),
            matched_css_rules=[RuleMatch.from_response(i) for i in response.get('matchedCSSRules')],
        )


@dataclass
class Value:
    '''
    Data for a simple selector (these are delimited by commas in a selector list).
    '''
    #: Value text.
    text: str

    #: Value range in the underlying resource (if available).
    range: SourceRange

    @classmethod
    def from_response(cls, response):
        return cls(
            text=str(response.get('text')),
            range=SourceRange.from_response(response.get('range')),
        )


@dataclass
class CSSRule:
    '''
    CSS rule representation.
    '''
    #: The css style sheet identifier (absent for user agent stylesheet and user-specified
    #: stylesheet rules) this rule came from.
    style_sheet_id: StyleSheetId

    #: Rule selector data.
    selector_list: SelectorList

    #: Parent stylesheet's origin.
    origin: StyleSheetOrigin

    #: Associated style declaration.
    style: CSSStyle

    #: Media list array (for rules involving media queries). The array enumerates media queries
    #: starting with the innermost one, going outwards.
    media: typing.List['CSSMedia']

    @classmethod
    def from_response(cls, response):
        return cls(
            style_sheet_id=StyleSheetId.from_response(response.get('styleSheetId')),
            selector_list=SelectorList.from_response(response.get('selectorList')),
            origin=StyleSheetOrigin.from_response(response.get('origin')),
            style=CSSStyle.from_response(response.get('style')),
            media=[CSSMedia.from_response(i) for i in response.get('media')],
        )


@dataclass
class CSSKeyframesRule:
    '''
    CSS keyframes rule representation.
    '''
    #: Animation name.
    animation_name: Value

    #: List of keyframes.
    keyframes: typing.List['CSSKeyframeRule']

    @classmethod
    def from_response(cls, response):
        return cls(
            animation_name=Value.from_response(response.get('animationName')),
            keyframes=[CSSKeyframeRule.from_response(i) for i in response.get('keyframes')],
        )


@dataclass
class CSSKeyframeRule:
    '''
    CSS keyframe rule representation.
    '''
    #: The css style sheet identifier (absent for user agent stylesheet and user-specified
    #: stylesheet rules) this rule came from.
    style_sheet_id: StyleSheetId

    #: Parent stylesheet's origin.
    origin: StyleSheetOrigin

    #: Associated key text.
    key_text: Value

    #: Associated style declaration.
    style: CSSStyle

    @classmethod
    def from_response(cls, response):
        return cls(
            style_sheet_id=StyleSheetId.from_response(response.get('styleSheetId')),
            origin=StyleSheetOrigin.from_response(response.get('origin')),
            key_text=Value.from_response(response.get('keyText')),
            style=CSSStyle.from_response(response.get('style')),
        )


@dataclass
class RuleMatch:
    '''
    Match data for a CSS rule.
    '''
    #: CSS rule in the match.
    rule: CSSRule

    #: Matching selector indices in the rule's selectorList selectors (0-based).
    matching_selectors: typing.List

    @classmethod
    def from_response(cls, response):
        return cls(
            rule=CSSRule.from_response(response.get('rule')),
            matching_selectors=[int(i) for i in response.get('matchingSelectors')],
        )

