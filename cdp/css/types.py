'''
DO NOT EDIT THIS FILE

This file is generated from the CDP definitions. If you need to make changes,
edit the generator and regenerate all of the modules.

Domain: css
Experimental: True
'''

from cdp.util import T_JSON_DICT
from dataclasses import dataclass
import enum
import typing

from ..dom import types as dom
from ..page import types as page


class StyleSheetId(str):
    def to_json(self) -> str:
        return self

    @classmethod
    def from_json(cls, json: str) -> 'StyleSheetId':
        return cls(json)

    def __repr__(self):
        return 'StyleSheetId({})'.format(super().__repr__())


class StyleSheetOrigin(enum.Enum):
    '''
    Stylesheet type: "injected" for stylesheets injected via extension, "user-agent" for user-agent
    stylesheets, "inspector" for stylesheets created by the inspector (i.e. those holding the "via
    inspector" rules), "regular" for regular stylesheets.
    '''
    INJECTED = "injected"
    USER_AGENT = "user-agent"
    INSPECTOR = "inspector"
    REGULAR = "regular"

    def to_json(self) -> str:
        return self.value

    @classmethod
    def from_json(cls, json: str) -> 'StyleSheetOrigin':
        return cls(json)


@dataclass
class PseudoElementMatches:
    '''
    CSS rule collection for a single pseudo style.
    '''
    #: Pseudo element type.
    pseudo_type: dom.PseudoType

    #: Matches of CSS rules applicable to the pseudo style.
    matches: typing.List['RuleMatch']

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {
            'pseudoType': self.pseudo_type.to_json(),
            'matches': [i.to_json() for i in self.matches],
        }
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> 'PseudoElementMatches':
        return cls(
            pseudo_type=dom.PseudoType.from_json(json['pseudoType']),
            matches=[RuleMatch.from_json(i) for i in json['matches']],
        )

@dataclass
class SelectorList:
    '''
    Selector list data.
    '''
    #: Selectors in the list.
    selectors: typing.List['Value']

    #: Rule selector text.
    text: str

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {
            'selectors': [i.to_json() for i in self.selectors],
            'text': self.text,
        }
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> 'SelectorList':
        return cls(
            selectors=[Value.from_json(i) for i in json['selectors']],
            text=json['text'],
        )

@dataclass
class CSSStyleSheetHeader:
    '''
    CSS stylesheet metainformation.
    '''
    #: The stylesheet identifier.
    style_sheet_id: StyleSheetId

    #: Owner frame identifier.
    frame_id: page.FrameId

    #: Stylesheet resource URL.
    source_url: str

    #: Stylesheet origin.
    origin: StyleSheetOrigin

    #: Stylesheet title.
    title: str

    #: Denotes whether the stylesheet is disabled.
    disabled: bool

    #: Whether this stylesheet is created for STYLE tag by parser. This flag is not set for
    #: document.written STYLE tags.
    is_inline: bool

    #: Line offset of the stylesheet within the resource (zero based).
    start_line: float

    #: Column offset of the stylesheet within the resource (zero based).
    start_column: float

    #: Size of the content (in characters).
    length: float

    #: URL of source map associated with the stylesheet (if any).
    source_map_url: typing.Optional[str] = None

    #: The backend id for the owner node of the stylesheet.
    owner_node: typing.Optional[dom.BackendNodeId] = None

    #: Whether the sourceURL field value comes from the sourceURL comment.
    has_source_url: typing.Optional[bool] = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {
            'styleSheetId': self.style_sheet_id.to_json(),
            'frameId': self.frame_id.to_json(),
            'sourceURL': self.source_url,
            'origin': self.origin.to_json(),
            'title': self.title,
            'disabled': self.disabled,
            'isInline': self.is_inline,
            'startLine': self.start_line,
            'startColumn': self.start_column,
            'length': self.length,
        }
        if self.source_map_url is not None:
            json['sourceMapURL'] = self.source_map_url
        if self.owner_node is not None:
            json['ownerNode'] = self.owner_node.to_json()
        if self.has_source_url is not None:
            json['hasSourceURL'] = self.has_source_url
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> 'CSSStyleSheetHeader':
        source_map_url = json['sourceMapURL'] if 'sourceMapURL' in json else None
        owner_node = dom.BackendNodeId.from_json(json['ownerNode']) if 'ownerNode' in json else None
        has_source_url = json['hasSourceURL'] if 'hasSourceURL' in json else None
        return cls(
            style_sheet_id=StyleSheetId.from_json(json['styleSheetId']),
            frame_id=page.FrameId.from_json(json['frameId']),
            source_url=json['sourceURL'],
            source_map_url=source_map_url,
            origin=StyleSheetOrigin.from_json(json['origin']),
            title=json['title'],
            owner_node=owner_node,
            disabled=json['disabled'],
            has_source_url=has_source_url,
            is_inline=json['isInline'],
            start_line=json['startLine'],
            start_column=json['startColumn'],
            length=json['length'],
        )

@dataclass
class RuleUsage:
    '''
    CSS coverage information.
    '''
    #: The css style sheet identifier (absent for user agent stylesheet and user-specified
    #: stylesheet rules) this rule came from.
    style_sheet_id: StyleSheetId

    #: Offset of the start of the rule (including selector) from the beginning of the stylesheet.
    start_offset: float

    #: Offset of the end of the rule body from the beginning of the stylesheet.
    end_offset: float

    #: Indicates whether the rule was actually used by some element in the page.
    used: bool

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {
            'styleSheetId': self.style_sheet_id.to_json(),
            'startOffset': self.start_offset,
            'endOffset': self.end_offset,
            'used': self.used,
        }
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> 'RuleUsage':
        return cls(
            style_sheet_id=StyleSheetId.from_json(json['styleSheetId']),
            start_offset=json['startOffset'],
            end_offset=json['endOffset'],
            used=json['used'],
        )

@dataclass
class SourceRange:
    '''
    Text range within a resource. All numbers are zero-based.
    '''
    #: Start line of range.
    start_line: int

    #: Start column of range (inclusive).
    start_column: int

    #: End line of range
    end_line: int

    #: End column of range (exclusive).
    end_column: int

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {
            'startLine': self.start_line,
            'startColumn': self.start_column,
            'endLine': self.end_line,
            'endColumn': self.end_column,
        }
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> 'SourceRange':
        return cls(
            start_line=json['startLine'],
            start_column=json['startColumn'],
            end_line=json['endLine'],
            end_column=json['endColumn'],
        )

@dataclass
class ShorthandEntry:
    #: Shorthand name.
    name: str

    #: Shorthand value.
    value: str

    #: Whether the property has "!important" annotation (implies `false` if absent).
    important: typing.Optional[bool] = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {
            'name': self.name,
            'value': self.value,
        }
        if self.important is not None:
            json['important'] = self.important
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> 'ShorthandEntry':
        important = json['important'] if 'important' in json else None
        return cls(
            name=json['name'],
            value=json['value'],
            important=important,
        )

@dataclass
class CSSComputedStyleProperty:
    #: Computed style property name.
    name: str

    #: Computed style property value.
    value: str

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {
            'name': self.name,
            'value': self.value,
        }
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> 'CSSComputedStyleProperty':
        return cls(
            name=json['name'],
            value=json['value'],
        )

@dataclass
class CSSStyle:
    '''
    CSS style representation.
    '''
    #: CSS properties in the style.
    css_properties: typing.List['CSSProperty']

    #: Computed values for all shorthands found in the style.
    shorthand_entries: typing.List['ShorthandEntry']

    #: The css style sheet identifier (absent for user agent stylesheet and user-specified
    #: stylesheet rules) this rule came from.
    style_sheet_id: typing.Optional[StyleSheetId] = None

    #: Style declaration text (if available).
    css_text: typing.Optional[str] = None

    #: Style declaration range in the enclosing stylesheet (if available).
    range: typing.Optional[SourceRange] = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {
            'cssProperties': [i.to_json() for i in self.css_properties],
            'shorthandEntries': [i.to_json() for i in self.shorthand_entries],
        }
        if self.style_sheet_id is not None:
            json['styleSheetId'] = self.style_sheet_id.to_json()
        if self.css_text is not None:
            json['cssText'] = self.css_text
        if self.range is not None:
            json['range'] = self.range.to_json()
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> 'CSSStyle':
        style_sheet_id = StyleSheetId.from_json(json['styleSheetId']) if 'styleSheetId' in json else None
        css_text = json['cssText'] if 'cssText' in json else None
        range = SourceRange.from_json(json['range']) if 'range' in json else None
        return cls(
            style_sheet_id=style_sheet_id,
            css_properties=[CSSProperty.from_json(i) for i in json['cssProperties']],
            shorthand_entries=[ShorthandEntry.from_json(i) for i in json['shorthandEntries']],
            css_text=css_text,
            range=range,
        )

@dataclass
class CSSProperty:
    '''
    CSS property declaration data.
    '''
    #: The property name.
    name: str

    #: The property value.
    value: str

    #: Whether the property has "!important" annotation (implies `false` if absent).
    important: typing.Optional[bool] = None

    #: Whether the property is implicit (implies `false` if absent).
    implicit: typing.Optional[bool] = None

    #: The full property text as specified in the style.
    text: typing.Optional[str] = None

    #: Whether the property is understood by the browser (implies `true` if absent).
    parsed_ok: typing.Optional[bool] = None

    #: Whether the property is disabled by the user (present for source-based properties only).
    disabled: typing.Optional[bool] = None

    #: The entire property range in the enclosing style declaration (if available).
    range: typing.Optional[SourceRange] = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {
            'name': self.name,
            'value': self.value,
        }
        if self.important is not None:
            json['important'] = self.important
        if self.implicit is not None:
            json['implicit'] = self.implicit
        if self.text is not None:
            json['text'] = self.text
        if self.parsed_ok is not None:
            json['parsedOk'] = self.parsed_ok
        if self.disabled is not None:
            json['disabled'] = self.disabled
        if self.range is not None:
            json['range'] = self.range.to_json()
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> 'CSSProperty':
        important = json['important'] if 'important' in json else None
        implicit = json['implicit'] if 'implicit' in json else None
        text = json['text'] if 'text' in json else None
        parsed_ok = json['parsedOk'] if 'parsedOk' in json else None
        disabled = json['disabled'] if 'disabled' in json else None
        range = SourceRange.from_json(json['range']) if 'range' in json else None
        return cls(
            name=json['name'],
            value=json['value'],
            important=important,
            implicit=implicit,
            text=text,
            parsed_ok=parsed_ok,
            disabled=disabled,
            range=range,
        )

@dataclass
class CSSMedia:
    '''
    CSS media rule descriptor.
    '''
    #: Media query text.
    text: str

    #: Source of the media query: "mediaRule" if specified by a @media rule, "importRule" if
    #: specified by an @import rule, "linkedSheet" if specified by a "media" attribute in a linked
    #: stylesheet's LINK tag, "inlineSheet" if specified by a "media" attribute in an inline
    #: stylesheet's STYLE tag.
    source: str

    #: URL of the document containing the media query description.
    source_url: typing.Optional[str] = None

    #: The associated rule (@media or @import) header range in the enclosing stylesheet (if
    #: available).
    range: typing.Optional[SourceRange] = None

    #: Identifier of the stylesheet containing this object (if exists).
    style_sheet_id: typing.Optional[StyleSheetId] = None

    #: Array of media queries.
    media_list: typing.Optional[typing.List['MediaQuery']] = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {
            'text': self.text,
            'source': self.source,
        }
        if self.source_url is not None:
            json['sourceURL'] = self.source_url
        if self.range is not None:
            json['range'] = self.range.to_json()
        if self.style_sheet_id is not None:
            json['styleSheetId'] = self.style_sheet_id.to_json()
        if self.media_list is not None:
            json['mediaList'] = [i.to_json() for i in self.media_list]
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> 'CSSMedia':
        source_url = json['sourceURL'] if 'sourceURL' in json else None
        range = SourceRange.from_json(json['range']) if 'range' in json else None
        style_sheet_id = StyleSheetId.from_json(json['styleSheetId']) if 'styleSheetId' in json else None
        media_list = [MediaQuery.from_json(i) for i in json['mediaList']] if 'mediaList' in json else None
        return cls(
            text=json['text'],
            source=json['source'],
            source_url=source_url,
            range=range,
            style_sheet_id=style_sheet_id,
            media_list=media_list,
        )

@dataclass
class MediaQuery:
    '''
    Media query descriptor.
    '''
    #: Array of media query expressions.
    expressions: typing.List['MediaQueryExpression']

    #: Whether the media query condition is satisfied.
    active: bool

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {
            'expressions': [i.to_json() for i in self.expressions],
            'active': self.active,
        }
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> 'MediaQuery':
        return cls(
            expressions=[MediaQueryExpression.from_json(i) for i in json['expressions']],
            active=json['active'],
        )

@dataclass
class MediaQueryExpression:
    '''
    Media query expression descriptor.
    '''
    #: Media query expression value.
    value: float

    #: Media query expression units.
    unit: str

    #: Media query expression feature.
    feature: str

    #: The associated range of the value text in the enclosing stylesheet (if available).
    value_range: typing.Optional[SourceRange] = None

    #: Computed length of media query expression (if applicable).
    computed_length: typing.Optional[float] = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {
            'value': self.value,
            'unit': self.unit,
            'feature': self.feature,
        }
        if self.value_range is not None:
            json['valueRange'] = self.value_range.to_json()
        if self.computed_length is not None:
            json['computedLength'] = self.computed_length
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> 'MediaQueryExpression':
        value_range = SourceRange.from_json(json['valueRange']) if 'valueRange' in json else None
        computed_length = json['computedLength'] if 'computedLength' in json else None
        return cls(
            value=json['value'],
            unit=json['unit'],
            feature=json['feature'],
            value_range=value_range,
            computed_length=computed_length,
        )

@dataclass
class PlatformFontUsage:
    '''
    Information about amount of glyphs that were rendered with given font.
    '''
    #: Font's family name reported by platform.
    family_name: str

    #: Indicates if the font was downloaded or resolved locally.
    is_custom_font: bool

    #: Amount of glyphs that were rendered with this font.
    glyph_count: float

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {
            'familyName': self.family_name,
            'isCustomFont': self.is_custom_font,
            'glyphCount': self.glyph_count,
        }
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> 'PlatformFontUsage':
        return cls(
            family_name=json['familyName'],
            is_custom_font=json['isCustomFont'],
            glyph_count=json['glyphCount'],
        )

@dataclass
class FontFace:
    '''
    Properties of a web font: https://www.w3.org/TR/2008/REC-CSS2-20080411/fonts.html#font-descriptions
    '''
    #: The font-family.
    font_family: str

    #: The font-style.
    font_style: str

    #: The font-variant.
    font_variant: str

    #: The font-weight.
    font_weight: str

    #: The font-stretch.
    font_stretch: str

    #: The unicode-range.
    unicode_range: str

    #: The src.
    src: str

    #: The resolved platform font family
    platform_font_family: str

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {
            'fontFamily': self.font_family,
            'fontStyle': self.font_style,
            'fontVariant': self.font_variant,
            'fontWeight': self.font_weight,
            'fontStretch': self.font_stretch,
            'unicodeRange': self.unicode_range,
            'src': self.src,
            'platformFontFamily': self.platform_font_family,
        }
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> 'FontFace':
        return cls(
            font_family=json['fontFamily'],
            font_style=json['fontStyle'],
            font_variant=json['fontVariant'],
            font_weight=json['fontWeight'],
            font_stretch=json['fontStretch'],
            unicode_range=json['unicodeRange'],
            src=json['src'],
            platform_font_family=json['platformFontFamily'],
        )

@dataclass
class StyleDeclarationEdit:
    '''
    A descriptor of operation to mutate style declaration text.
    '''
    #: The css style sheet identifier.
    style_sheet_id: StyleSheetId

    #: The range of the style text in the enclosing stylesheet.
    range: SourceRange

    #: New style text.
    text: str

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {
            'styleSheetId': self.style_sheet_id.to_json(),
            'range': self.range.to_json(),
            'text': self.text,
        }
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> 'StyleDeclarationEdit':
        return cls(
            style_sheet_id=StyleSheetId.from_json(json['styleSheetId']),
            range=SourceRange.from_json(json['range']),
            text=json['text'],
        )

@dataclass
class InheritedStyleEntry:
    '''
    Inherited CSS rule collection from ancestor node.
    '''
    #: Matches of CSS rules matching the ancestor node in the style inheritance chain.
    matched_css_rules: typing.List['RuleMatch']

    #: The ancestor node's inline style, if any, in the style inheritance chain.
    inline_style: typing.Optional[CSSStyle] = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {
            'matchedCSSRules': [i.to_json() for i in self.matched_css_rules],
        }
        if self.inline_style is not None:
            json['inlineStyle'] = self.inline_style.to_json()
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> 'InheritedStyleEntry':
        inline_style = CSSStyle.from_json(json['inlineStyle']) if 'inlineStyle' in json else None
        return cls(
            inline_style=inline_style,
            matched_css_rules=[RuleMatch.from_json(i) for i in json['matchedCSSRules']],
        )

@dataclass
class Value:
    '''
    Data for a simple selector (these are delimited by commas in a selector list).
    '''
    #: Value text.
    text: str

    #: Value range in the underlying resource (if available).
    range: typing.Optional[SourceRange] = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {
            'text': self.text,
        }
        if self.range is not None:
            json['range'] = self.range.to_json()
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> 'Value':
        range = SourceRange.from_json(json['range']) if 'range' in json else None
        return cls(
            text=json['text'],
            range=range,
        )

@dataclass
class CSSRule:
    '''
    CSS rule representation.
    '''
    #: Rule selector data.
    selector_list: SelectorList

    #: Parent stylesheet's origin.
    origin: StyleSheetOrigin

    #: Associated style declaration.
    style: CSSStyle

    #: The css style sheet identifier (absent for user agent stylesheet and user-specified
    #: stylesheet rules) this rule came from.
    style_sheet_id: typing.Optional[StyleSheetId] = None

    #: Media list array (for rules involving media queries). The array enumerates media queries
    #: starting with the innermost one, going outwards.
    media: typing.Optional[typing.List['CSSMedia']] = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {
            'selectorList': self.selector_list.to_json(),
            'origin': self.origin.to_json(),
            'style': self.style.to_json(),
        }
        if self.style_sheet_id is not None:
            json['styleSheetId'] = self.style_sheet_id.to_json()
        if self.media is not None:
            json['media'] = [i.to_json() for i in self.media]
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> 'CSSRule':
        style_sheet_id = StyleSheetId.from_json(json['styleSheetId']) if 'styleSheetId' in json else None
        media = [CSSMedia.from_json(i) for i in json['media']] if 'media' in json else None
        return cls(
            style_sheet_id=style_sheet_id,
            selector_list=SelectorList.from_json(json['selectorList']),
            origin=StyleSheetOrigin.from_json(json['origin']),
            style=CSSStyle.from_json(json['style']),
            media=media,
        )

@dataclass
class CSSKeyframesRule:
    '''
    CSS keyframes rule representation.
    '''
    #: Animation name.
    animation_name: Value

    #: List of keyframes.
    keyframes: typing.List['CSSKeyframeRule']

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {
            'animationName': self.animation_name.to_json(),
            'keyframes': [i.to_json() for i in self.keyframes],
        }
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> 'CSSKeyframesRule':
        return cls(
            animation_name=Value.from_json(json['animationName']),
            keyframes=[CSSKeyframeRule.from_json(i) for i in json['keyframes']],
        )

@dataclass
class CSSKeyframeRule:
    '''
    CSS keyframe rule representation.
    '''
    #: Parent stylesheet's origin.
    origin: StyleSheetOrigin

    #: Associated key text.
    key_text: Value

    #: Associated style declaration.
    style: CSSStyle

    #: The css style sheet identifier (absent for user agent stylesheet and user-specified
    #: stylesheet rules) this rule came from.
    style_sheet_id: typing.Optional[StyleSheetId] = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {
            'origin': self.origin.to_json(),
            'keyText': self.key_text.to_json(),
            'style': self.style.to_json(),
        }
        if self.style_sheet_id is not None:
            json['styleSheetId'] = self.style_sheet_id.to_json()
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> 'CSSKeyframeRule':
        style_sheet_id = StyleSheetId.from_json(json['styleSheetId']) if 'styleSheetId' in json else None
        return cls(
            style_sheet_id=style_sheet_id,
            origin=StyleSheetOrigin.from_json(json['origin']),
            key_text=Value.from_json(json['keyText']),
            style=CSSStyle.from_json(json['style']),
        )

@dataclass
class RuleMatch:
    '''
    Match data for a CSS rule.
    '''
    #: CSS rule in the match.
    rule: CSSRule

    #: Matching selector indices in the rule's selectorList selectors (0-based).
    matching_selectors: typing.List['int']

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {
            'rule': self.rule.to_json(),
            'matchingSelectors': [i for i in self.matching_selectors],
        }
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> 'RuleMatch':
        return cls(
            rule=CSSRule.from_json(json['rule']),
            matching_selectors=[i for i in json['matchingSelectors']],
        )

