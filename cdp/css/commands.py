'''
DO NOT EDIT THIS FILE

This file is generated from the CDP definitions. If you need to make changes,
edit the generator and regenerate all of the modules.

Domain: css
Experimental: True
'''

from cdp.util import T_JSON_DICT
from dataclasses import dataclass
import enum
import typing

from .types import *
from ..dom import types as dom
from ..page import types as page



def add_rule(
        style_sheet_id: StyleSheetId,
        rule_text: str,
        location: SourceRange,
    ) -> typing.Generator[T_JSON_DICT,T_JSON_DICT,CSSRule]:
    '''
    Inserts a new rule with the given `ruleText` in a stylesheet with given `styleSheetId`, at the
    position specified by `location`.
    
    :param style_sheet_id: The css style sheet identifier where a new rule should be inserted.
    :param rule_text: The text of a new rule.
    :param location: Text position of a new rule in the target style sheet.
    :returns: The newly created rule.
    '''
    params: T_JSON_DICT = {
        'styleSheetId': style_sheet_id.to_json(),
        'ruleText': rule_text,
        'location': location.to_json(),
    }
    cmd_dict: T_JSON_DICT = {
        'method': 'CSS.addRule',
        'params': params,
    }
    json = yield cmd_dict
    return CSSRule.from_json(json['rule'])


def collect_class_names(
        style_sheet_id: StyleSheetId,
    ) -> typing.Generator[T_JSON_DICT,T_JSON_DICT,typing.List['str']]:
    '''
    Returns all class names from specified stylesheet.
    
    :param style_sheet_id: 
    :returns: Class name list.
    '''
    params: T_JSON_DICT = {
        'styleSheetId': style_sheet_id.to_json(),
    }
    cmd_dict: T_JSON_DICT = {
        'method': 'CSS.collectClassNames',
        'params': params,
    }
    json = yield cmd_dict
    return [str(i) for i in json['classNames']]


def create_style_sheet(
        frame_id: page.FrameId,
    ) -> typing.Generator[T_JSON_DICT,T_JSON_DICT,StyleSheetId]:
    '''
    Creates a new special "via-inspector" stylesheet in the frame with given `frameId`.
    
    :param frame_id: Identifier of the frame where "via-inspector" stylesheet should be created.
    :returns: Identifier of the created "via-inspector" stylesheet.
    '''
    params: T_JSON_DICT = {
        'frameId': frame_id.to_json(),
    }
    cmd_dict: T_JSON_DICT = {
        'method': 'CSS.createStyleSheet',
        'params': params,
    }
    json = yield cmd_dict
    return StyleSheetId.from_json(json['styleSheetId'])


def disable() -> typing.Generator[T_JSON_DICT,T_JSON_DICT,None]:
    '''
    Disables the CSS agent for the given page.
    '''
    cmd_dict: T_JSON_DICT = {
        'method': 'CSS.disable',
    }
    json = yield cmd_dict


def enable() -> typing.Generator[T_JSON_DICT,T_JSON_DICT,None]:
    '''
    Enables the CSS agent for the given page. Clients should not assume that the CSS agent has been
    enabled until the result of this command is received.
    '''
    cmd_dict: T_JSON_DICT = {
        'method': 'CSS.enable',
    }
    json = yield cmd_dict


def force_pseudo_state(
        node_id: dom.NodeId,
        forced_pseudo_classes: typing.List['str'],
    ) -> typing.Generator[T_JSON_DICT,T_JSON_DICT,None]:
    '''
    Ensures that the given node will have specified pseudo-classes whenever its style is computed by
    the browser.
    
    :param node_id: The element id for which to force the pseudo state.
    :param forced_pseudo_classes: Element pseudo classes to force when computing the element's style.
    '''
    params: T_JSON_DICT = {
        'nodeId': node_id.to_json(),
        'forcedPseudoClasses': [i for i in forced_pseudo_classes],
    }
    cmd_dict: T_JSON_DICT = {
        'method': 'CSS.forcePseudoState',
        'params': params,
    }
    json = yield cmd_dict


def get_background_colors(
        node_id: dom.NodeId,
    ) -> typing.Generator[T_JSON_DICT,T_JSON_DICT,dict]:
    '''
    
    
    :param node_id: Id of the node to get background colors for.
    :returns: a dict with the following keys:
        * backgroundColors: (Optional) The range of background colors behind this element, if it contains any visible text. If no
    visible text is present, this will be undefined. In the case of a flat background color,
    this will consist of simply that color. In the case of a gradient, this will consist of each
    of the color stops. For anything more complicated, this will be an empty array. Images will
    be ignored (as if the image had failed to load).
        * computedFontSize: (Optional) The computed font size for this node, as a CSS computed value string (e.g. '12px').
        * computedFontWeight: (Optional) The computed font weight for this node, as a CSS computed value string (e.g. 'normal' or
    '100').
    '''
    params: T_JSON_DICT = {
        'nodeId': node_id.to_json(),
    }
    cmd_dict: T_JSON_DICT = {
        'method': 'CSS.getBackgroundColors',
        'params': params,
    }
    json = yield cmd_dict
    result: T_JSON_DICT = {
    }
    if 'backgroundColors' in json:
        result['backgroundColors'] = [str(i) for i in json['backgroundColors']]
    if 'computedFontSize' in json:
        result['computedFontSize'] = str(json['computedFontSize'])
    if 'computedFontWeight' in json:
        result['computedFontWeight'] = str(json['computedFontWeight'])
    return result


def get_computed_style_for_node(
        node_id: dom.NodeId,
    ) -> typing.Generator[T_JSON_DICT,T_JSON_DICT,typing.List['CSSComputedStyleProperty']]:
    '''
    Returns the computed style for a DOM node identified by `nodeId`.
    
    :param node_id: 
    :returns: Computed style for the specified DOM node.
    '''
    params: T_JSON_DICT = {
        'nodeId': node_id.to_json(),
    }
    cmd_dict: T_JSON_DICT = {
        'method': 'CSS.getComputedStyleForNode',
        'params': params,
    }
    json = yield cmd_dict
    return [CSSComputedStyleProperty.from_json(i) for i in json['computedStyle']]


def get_inline_styles_for_node(
        node_id: dom.NodeId,
    ) -> typing.Generator[T_JSON_DICT,T_JSON_DICT,dict]:
    '''
    Returns the styles defined inline (explicitly in the "style" attribute and implicitly, using DOM
    attributes) for a DOM node identified by `nodeId`.
    
    :param node_id: 
    :returns: a dict with the following keys:
        * inlineStyle: (Optional) Inline style for the specified DOM node.
        * attributesStyle: (Optional) Attribute-defined element style (e.g. resulting from "width=20 height=100%").
    '''
    params: T_JSON_DICT = {
        'nodeId': node_id.to_json(),
    }
    cmd_dict: T_JSON_DICT = {
        'method': 'CSS.getInlineStylesForNode',
        'params': params,
    }
    json = yield cmd_dict
    result: T_JSON_DICT = {
    }
    if 'inlineStyle' in json:
        result['inlineStyle'] = CSSStyle.from_json(json['inlineStyle'])
    if 'attributesStyle' in json:
        result['attributesStyle'] = CSSStyle.from_json(json['attributesStyle'])
    return result


def get_matched_styles_for_node(
        node_id: dom.NodeId,
    ) -> typing.Generator[T_JSON_DICT,T_JSON_DICT,dict]:
    '''
    Returns requested styles for a DOM node identified by `nodeId`.
    
    :param node_id: 
    :returns: a dict with the following keys:
        * inlineStyle: (Optional) Inline style for the specified DOM node.
        * attributesStyle: (Optional) Attribute-defined element style (e.g. resulting from "width=20 height=100%").
        * matchedCSSRules: (Optional) CSS rules matching this node, from all applicable stylesheets.
        * pseudoElements: (Optional) Pseudo style matches for this node.
        * inherited: (Optional) A chain of inherited styles (from the immediate node parent up to the DOM tree root).
        * cssKeyframesRules: (Optional) A list of CSS keyframed animations matching this node.
    '''
    params: T_JSON_DICT = {
        'nodeId': node_id.to_json(),
    }
    cmd_dict: T_JSON_DICT = {
        'method': 'CSS.getMatchedStylesForNode',
        'params': params,
    }
    json = yield cmd_dict
    result: T_JSON_DICT = {
    }
    if 'inlineStyle' in json:
        result['inlineStyle'] = CSSStyle.from_json(json['inlineStyle'])
    if 'attributesStyle' in json:
        result['attributesStyle'] = CSSStyle.from_json(json['attributesStyle'])
    if 'matchedCSSRules' in json:
        result['matchedCSSRules'] = [RuleMatch.from_json(i) for i in json['matchedCSSRules']]
    if 'pseudoElements' in json:
        result['pseudoElements'] = [PseudoElementMatches.from_json(i) for i in json['pseudoElements']]
    if 'inherited' in json:
        result['inherited'] = [InheritedStyleEntry.from_json(i) for i in json['inherited']]
    if 'cssKeyframesRules' in json:
        result['cssKeyframesRules'] = [CSSKeyframesRule.from_json(i) for i in json['cssKeyframesRules']]
    return result


def get_media_queries() -> typing.Generator[T_JSON_DICT,T_JSON_DICT,typing.List['CSSMedia']]:
    '''
    Returns all media queries parsed by the rendering engine.
    :returns: 
    '''
    cmd_dict: T_JSON_DICT = {
        'method': 'CSS.getMediaQueries',
    }
    json = yield cmd_dict
    return [CSSMedia.from_json(i) for i in json['medias']]


def get_platform_fonts_for_node(
        node_id: dom.NodeId,
    ) -> typing.Generator[T_JSON_DICT,T_JSON_DICT,typing.List['PlatformFontUsage']]:
    '''
    Requests information about platform fonts which we used to render child TextNodes in the given
    node.
    
    :param node_id: 
    :returns: Usage statistics for every employed platform font.
    '''
    params: T_JSON_DICT = {
        'nodeId': node_id.to_json(),
    }
    cmd_dict: T_JSON_DICT = {
        'method': 'CSS.getPlatformFontsForNode',
        'params': params,
    }
    json = yield cmd_dict
    return [PlatformFontUsage.from_json(i) for i in json['fonts']]


def get_style_sheet_text(
        style_sheet_id: StyleSheetId,
    ) -> typing.Generator[T_JSON_DICT,T_JSON_DICT,str]:
    '''
    Returns the current textual content for a stylesheet.
    
    :param style_sheet_id: 
    :returns: The stylesheet text.
    '''
    params: T_JSON_DICT = {
        'styleSheetId': style_sheet_id.to_json(),
    }
    cmd_dict: T_JSON_DICT = {
        'method': 'CSS.getStyleSheetText',
        'params': params,
    }
    json = yield cmd_dict
    return str(json['text'])


def set_effective_property_value_for_node(
        node_id: dom.NodeId,
        property_name: str,
        value: str,
    ) -> typing.Generator[T_JSON_DICT,T_JSON_DICT,None]:
    '''
    Find a rule with the given active property for the given node and set the new value for this
    property
    
    :param node_id: The element id for which to set property.
    :param property_name: 
    :param value: 
    '''
    params: T_JSON_DICT = {
        'nodeId': node_id.to_json(),
        'propertyName': property_name,
        'value': value,
    }
    cmd_dict: T_JSON_DICT = {
        'method': 'CSS.setEffectivePropertyValueForNode',
        'params': params,
    }
    json = yield cmd_dict


def set_keyframe_key(
        style_sheet_id: StyleSheetId,
        range: SourceRange,
        key_text: str,
    ) -> typing.Generator[T_JSON_DICT,T_JSON_DICT,Value]:
    '''
    Modifies the keyframe rule key text.
    
    :param style_sheet_id: 
    :param range: 
    :param key_text: 
    :returns: The resulting key text after modification.
    '''
    params: T_JSON_DICT = {
        'styleSheetId': style_sheet_id.to_json(),
        'range': range.to_json(),
        'keyText': key_text,
    }
    cmd_dict: T_JSON_DICT = {
        'method': 'CSS.setKeyframeKey',
        'params': params,
    }
    json = yield cmd_dict
    return Value.from_json(json['keyText'])


def set_media_text(
        style_sheet_id: StyleSheetId,
        range: SourceRange,
        text: str,
    ) -> typing.Generator[T_JSON_DICT,T_JSON_DICT,CSSMedia]:
    '''
    Modifies the rule selector.
    
    :param style_sheet_id: 
    :param range: 
    :param text: 
    :returns: The resulting CSS media rule after modification.
    '''
    params: T_JSON_DICT = {
        'styleSheetId': style_sheet_id.to_json(),
        'range': range.to_json(),
        'text': text,
    }
    cmd_dict: T_JSON_DICT = {
        'method': 'CSS.setMediaText',
        'params': params,
    }
    json = yield cmd_dict
    return CSSMedia.from_json(json['media'])


def set_rule_selector(
        style_sheet_id: StyleSheetId,
        range: SourceRange,
        selector: str,
    ) -> typing.Generator[T_JSON_DICT,T_JSON_DICT,SelectorList]:
    '''
    Modifies the rule selector.
    
    :param style_sheet_id: 
    :param range: 
    :param selector: 
    :returns: The resulting selector list after modification.
    '''
    params: T_JSON_DICT = {
        'styleSheetId': style_sheet_id.to_json(),
        'range': range.to_json(),
        'selector': selector,
    }
    cmd_dict: T_JSON_DICT = {
        'method': 'CSS.setRuleSelector',
        'params': params,
    }
    json = yield cmd_dict
    return SelectorList.from_json(json['selectorList'])


def set_style_sheet_text(
        style_sheet_id: StyleSheetId,
        text: str,
    ) -> typing.Generator[T_JSON_DICT,T_JSON_DICT,str]:
    '''
    Sets the new stylesheet text.
    
    :param style_sheet_id: 
    :param text: 
    :returns: URL of source map associated with script (if any).
    '''
    params: T_JSON_DICT = {
        'styleSheetId': style_sheet_id.to_json(),
        'text': text,
    }
    cmd_dict: T_JSON_DICT = {
        'method': 'CSS.setStyleSheetText',
        'params': params,
    }
    json = yield cmd_dict
    return str(json['sourceMapURL'])


def set_style_texts(
        edits: typing.List['StyleDeclarationEdit'],
    ) -> typing.Generator[T_JSON_DICT,T_JSON_DICT,typing.List['CSSStyle']]:
    '''
    Applies specified style edits one after another in the given order.
    
    :param edits: 
    :returns: The resulting styles after modification.
    '''
    params: T_JSON_DICT = {
        'edits': [i.to_json() for i in edits],
    }
    cmd_dict: T_JSON_DICT = {
        'method': 'CSS.setStyleTexts',
        'params': params,
    }
    json = yield cmd_dict
    return [CSSStyle.from_json(i) for i in json['styles']]


def start_rule_usage_tracking() -> typing.Generator[T_JSON_DICT,T_JSON_DICT,None]:
    '''
    Enables the selector recording.
    '''
    cmd_dict: T_JSON_DICT = {
        'method': 'CSS.startRuleUsageTracking',
    }
    json = yield cmd_dict


def stop_rule_usage_tracking() -> typing.Generator[T_JSON_DICT,T_JSON_DICT,typing.List['RuleUsage']]:
    '''
    Stop tracking rule usage and return the list of rules that were used since last call to
    `takeCoverageDelta` (or since start of coverage instrumentation)
    :returns: 
    '''
    cmd_dict: T_JSON_DICT = {
        'method': 'CSS.stopRuleUsageTracking',
    }
    json = yield cmd_dict
    return [RuleUsage.from_json(i) for i in json['ruleUsage']]


def take_coverage_delta() -> typing.Generator[T_JSON_DICT,T_JSON_DICT,typing.List['RuleUsage']]:
    '''
    Obtain list of rules that became used since last call to this method (or since start of coverage
    instrumentation)
    :returns: 
    '''
    cmd_dict: T_JSON_DICT = {
        'method': 'CSS.takeCoverageDelta',
    }
    json = yield cmd_dict
    return [RuleUsage.from_json(i) for i in json['coverage']]


