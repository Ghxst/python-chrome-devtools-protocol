'''
DO NOT EDIT THIS FILE

This file is generated from the CDP definitions. If you need to make changes,
edit the generator and regenerate all of the modules.

Domain: target
Experimental: False
'''

from cdp.util import T_JSON_DICT
from dataclasses import dataclass
import enum
import typing


class TargetID(str):
    def to_json(self) -> str:
        return self

    @classmethod
    def from_json(cls, json: str) -> 'TargetID':
        return cls(json)

    def __repr__(self):
        return 'TargetID({})'.format(super().__repr__())


class SessionID(str):
    '''
    Unique identifier of attached debugging session.
    '''
    def to_json(self) -> str:
        return self

    @classmethod
    def from_json(cls, json: str) -> 'SessionID':
        return cls(json)

    def __repr__(self):
        return 'SessionID({})'.format(super().__repr__())


class BrowserContextID(str):
    def to_json(self) -> str:
        return self

    @classmethod
    def from_json(cls, json: str) -> 'BrowserContextID':
        return cls(json)

    def __repr__(self):
        return 'BrowserContextID({})'.format(super().__repr__())


@dataclass
class TargetInfo:
    target_id: TargetID

    type: str

    title: str

    url: str

    #: Whether the target has an attached client.
    attached: bool

    #: Opener target Id
    opener_id: typing.Optional[TargetID] = None

    browser_context_id: typing.Optional[BrowserContextID] = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {
            'targetId': self.target_id.to_json(),
            'type': self.type,
            'title': self.title,
            'url': self.url,
            'attached': self.attached,
        }
        if self.opener_id is not None:
            json['openerId'] = self.opener_id.to_json()
        if self.browser_context_id is not None:
            json['browserContextId'] = self.browser_context_id.to_json()
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> 'TargetInfo':
        opener_id = TargetID.from_json(json['openerId']) if 'openerId' in json else None
        browser_context_id = BrowserContextID.from_json(json['browserContextId']) if 'browserContextId' in json else None
        return cls(
            target_id=TargetID.from_json(json['targetId']),
            type=json['type'],
            title=json['title'],
            url=json['url'],
            attached=json['attached'],
            opener_id=opener_id,
            browser_context_id=browser_context_id,
        )

@dataclass
class RemoteLocation:
    host: str

    port: int

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {
            'host': self.host,
            'port': self.port,
        }
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> 'RemoteLocation':
        return cls(
            host=json['host'],
            port=json['port'],
        )

