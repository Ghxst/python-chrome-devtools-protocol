'''
DO NOT EDIT THIS FILE

This file is generated from the CDP definitions. If you need to make changes,
edit the generator and regenerate all of the modules.

Domain: web_audio
Experimental: True
'''

from cdp.util import T_JSON_DICT
from dataclasses import dataclass
import enum
import typing


class ContextId(str):
    '''
    Context's UUID in string
    '''
    def to_json(self) -> str:
        return self

    @classmethod
    def from_json(cls, json: str) -> 'ContextId':
        return cls(json)

    def __repr__(self):
        return 'ContextId({})'.format(str.__repr__(self))


class ContextType(enum.Enum):
    '''
    Enum of BaseAudioContext types
    '''
    REALTIME = "realtime"
    OFFLINE = "offline"

    def to_json(self) -> str:
        return self.value

    @classmethod
    def from_json(cls, json: str) -> 'ContextType':
        return cls(json)


class ContextState(enum.Enum):
    '''
    Enum of AudioContextState from the spec
    '''
    SUSPENDED = "suspended"
    RUNNING = "running"
    CLOSED = "closed"

    def to_json(self) -> str:
        return self.value

    @classmethod
    def from_json(cls, json: str) -> 'ContextState':
        return cls(json)


@dataclass
class ContextRealtimeData:
    '''
    Fields in AudioContext that change in real-time. These are not updated
    on OfflineAudioContext.
    '''
    #: The current context time in second in BaseAudioContext.
    current_time: typing.Optional[float] = None

    #: The time spent on rendering graph divided by render qunatum duration,
    #: and multiplied by 100. 100 means the audio renderer reached the full
    #: capacity and glitch may occur.
    render_capacity: typing.Optional[float] = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {
        }
        if self.current_time is not None:
            json['currentTime'] = self.current_time
        if self.render_capacity is not None:
            json['renderCapacity'] = self.render_capacity
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> 'ContextRealtimeData':
        current_time = json['currentTime'] if 'currentTime' in json else None
        render_capacity = json['renderCapacity'] if 'renderCapacity' in json else None
        return cls(
            current_time=current_time,
            render_capacity=render_capacity,
        )

@dataclass
class BaseAudioContext:
    '''
    Protocol object for BaseAudioContext
    '''
    context_id: ContextId

    context_type: ContextType

    context_state: ContextState

    #: Platform-dependent callback buffer size.
    callback_buffer_size: float

    #: Number of output channels supported by audio hardware in use.
    max_output_channel_count: float

    #: Context sample rate.
    sample_rate: float

    realtime_data: typing.Optional[ContextRealtimeData] = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {
            'contextId': self.context_id.to_json(),
            'contextType': self.context_type.to_json(),
            'contextState': self.context_state.to_json(),
            'callbackBufferSize': self.callback_buffer_size,
            'maxOutputChannelCount': self.max_output_channel_count,
            'sampleRate': self.sample_rate,
        }
        if self.realtime_data is not None:
            json['realtimeData'] = self.realtime_data.to_json()
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> 'BaseAudioContext':
        realtime_data = ContextRealtimeData.from_json(json['realtimeData']) if 'realtimeData' in json else None
        return cls(
            context_id=ContextId.from_json(json['contextId']),
            context_type=ContextType.from_json(json['contextType']),
            context_state=ContextState.from_json(json['contextState']),
            realtime_data=realtime_data,
            callback_buffer_size=json['callbackBufferSize'],
            max_output_channel_count=json['maxOutputChannelCount'],
            sample_rate=json['sampleRate'],
        )

