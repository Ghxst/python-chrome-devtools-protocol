'''
DO NOT EDIT THIS FILE

This file is generated from the CDP definitions. If you need to make changes,
edit the generator and regenerate all of the modules.

Domain: profiler
Experimental: False
'''

from cdp.util import T_JSON_DICT
from dataclasses import dataclass
import enum
import typing

from ..runtime import types as runtime


@dataclass
class ProfileNode:
    '''
    Profile node. Holds callsite information, execution statistics and child nodes.
    '''
    #: Unique id of the node.
    id: int

    #: Function location.
    call_frame: runtime.CallFrame

    #: Number of samples where this node was on top of the call stack.
    hit_count: typing.Optional[int] = None

    #: Child node ids.
    children: typing.Optional[typing.List['int']] = None

    #: The reason of being not optimized. The function may be deoptimized or marked as don't
    #: optimize.
    deopt_reason: typing.Optional[str] = None

    #: An array of source position ticks.
    position_ticks: typing.Optional[typing.List['PositionTickInfo']] = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {
            'id': self.id,
            'callFrame': self.call_frame.to_json(),
        }
        if self.hit_count is not None:
            json['hitCount'] = self.hit_count
        if self.children is not None:
            json['children'] = [i for i in self.children]
        if self.deopt_reason is not None:
            json['deoptReason'] = self.deopt_reason
        if self.position_ticks is not None:
            json['positionTicks'] = [i.to_json() for i in self.position_ticks]
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> 'ProfileNode':
        hit_count = json['hitCount'] if 'hitCount' in json else None
        children = [i for i in json['children']] if 'children' in json else None
        deopt_reason = json['deoptReason'] if 'deoptReason' in json else None
        position_ticks = [PositionTickInfo.from_json(i) for i in json['positionTicks']] if 'positionTicks' in json else None
        return cls(
            id=json['id'],
            call_frame=runtime.CallFrame.from_json(json['callFrame']),
            hit_count=hit_count,
            children=children,
            deopt_reason=deopt_reason,
            position_ticks=position_ticks,
        )

@dataclass
class Profile:
    '''
    Profile.
    '''
    #: The list of profile nodes. First item is the root node.
    nodes: typing.List['ProfileNode']

    #: Profiling start timestamp in microseconds.
    start_time: float

    #: Profiling end timestamp in microseconds.
    end_time: float

    #: Ids of samples top nodes.
    samples: typing.Optional[typing.List['int']] = None

    #: Time intervals between adjacent samples in microseconds. The first delta is relative to the
    #: profile startTime.
    time_deltas: typing.Optional[typing.List['int']] = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {
            'nodes': [i.to_json() for i in self.nodes],
            'startTime': self.start_time,
            'endTime': self.end_time,
        }
        if self.samples is not None:
            json['samples'] = [i for i in self.samples]
        if self.time_deltas is not None:
            json['timeDeltas'] = [i for i in self.time_deltas]
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> 'Profile':
        samples = [i for i in json['samples']] if 'samples' in json else None
        time_deltas = [i for i in json['timeDeltas']] if 'timeDeltas' in json else None
        return cls(
            nodes=[ProfileNode.from_json(i) for i in json['nodes']],
            start_time=json['startTime'],
            end_time=json['endTime'],
            samples=samples,
            time_deltas=time_deltas,
        )

@dataclass
class PositionTickInfo:
    '''
    Specifies a number of samples attributed to a certain source position.
    '''
    #: Source line number (1-based).
    line: int

    #: Number of samples attributed to the source line.
    ticks: int

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {
            'line': self.line,
            'ticks': self.ticks,
        }
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> 'PositionTickInfo':
        return cls(
            line=json['line'],
            ticks=json['ticks'],
        )

@dataclass
class CoverageRange:
    '''
    Coverage data for a source range.
    '''
    #: JavaScript script source offset for the range start.
    start_offset: int

    #: JavaScript script source offset for the range end.
    end_offset: int

    #: Collected execution count of the source range.
    count: int

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {
            'startOffset': self.start_offset,
            'endOffset': self.end_offset,
            'count': self.count,
        }
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> 'CoverageRange':
        return cls(
            start_offset=json['startOffset'],
            end_offset=json['endOffset'],
            count=json['count'],
        )

@dataclass
class FunctionCoverage:
    '''
    Coverage data for a JavaScript function.
    '''
    #: JavaScript function name.
    function_name: str

    #: Source ranges inside the function with coverage data.
    ranges: typing.List['CoverageRange']

    #: Whether coverage data for this function has block granularity.
    is_block_coverage: bool

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {
            'functionName': self.function_name,
            'ranges': [i.to_json() for i in self.ranges],
            'isBlockCoverage': self.is_block_coverage,
        }
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> 'FunctionCoverage':
        return cls(
            function_name=json['functionName'],
            ranges=[CoverageRange.from_json(i) for i in json['ranges']],
            is_block_coverage=json['isBlockCoverage'],
        )

@dataclass
class ScriptCoverage:
    '''
    Coverage data for a JavaScript script.
    '''
    #: JavaScript script id.
    script_id: runtime.ScriptId

    #: JavaScript script name or url.
    url: str

    #: Functions contained in the script that has coverage data.
    functions: typing.List['FunctionCoverage']

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {
            'scriptId': self.script_id.to_json(),
            'url': self.url,
            'functions': [i.to_json() for i in self.functions],
        }
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> 'ScriptCoverage':
        return cls(
            script_id=runtime.ScriptId.from_json(json['scriptId']),
            url=json['url'],
            functions=[FunctionCoverage.from_json(i) for i in json['functions']],
        )

@dataclass
class TypeObject:
    '''
    Describes a type collected during runtime.
    '''
    #: Name of a type collected with type profiling.
    name: str

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {
            'name': self.name,
        }
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> 'TypeObject':
        return cls(
            name=json['name'],
        )

@dataclass
class TypeProfileEntry:
    '''
    Source offset and types for a parameter or return value.
    '''
    #: Source offset of the parameter or end of function for return values.
    offset: int

    #: The types for this parameter or return value.
    types: typing.List['TypeObject']

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {
            'offset': self.offset,
            'types': [i.to_json() for i in self.types],
        }
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> 'TypeProfileEntry':
        return cls(
            offset=json['offset'],
            types=[TypeObject.from_json(i) for i in json['types']],
        )

@dataclass
class ScriptTypeProfile:
    '''
    Type profile data collected during runtime for a JavaScript script.
    '''
    #: JavaScript script id.
    script_id: runtime.ScriptId

    #: JavaScript script name or url.
    url: str

    #: Type profile entries for parameters and return values of the functions in the script.
    entries: typing.List['TypeProfileEntry']

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {
            'scriptId': self.script_id.to_json(),
            'url': self.url,
            'entries': [i.to_json() for i in self.entries],
        }
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> 'ScriptTypeProfile':
        return cls(
            script_id=runtime.ScriptId.from_json(json['scriptId']),
            url=json['url'],
            entries=[TypeProfileEntry.from_json(i) for i in json['entries']],
        )

