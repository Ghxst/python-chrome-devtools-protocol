'''
DO NOT EDIT THIS FILE

This file is generated from the CDP definitions. If you need to make changes,
edit the generator and regenerate all of the modules.

Domain: indexed_db
Experimental: True
'''

from cdp.util import T_JSON_DICT
from dataclasses import dataclass
import enum
import typing

from ..runtime import types as runtime


@dataclass
class DatabaseWithObjectStores:
    '''
    Database with an array of object stores.
    '''
    #: Database name.
    name: str

    #: Database version (type is not 'integer', as the standard
    #: requires the version number to be 'unsigned long long')
    version: float

    #: Object stores in this database.
    object_stores: typing.List['ObjectStore']

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {
            'name': self.name,
            'version': self.version,
            'objectStores': [i.to_json() for i in self.object_stores],
        }
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> 'DatabaseWithObjectStores':
        return cls(
            name=json['name'],
            version=json['version'],
            object_stores=[ObjectStore.from_json(i) for i in json['objectStores']],
        )

@dataclass
class Key:
    '''
    Key.
    '''
    #: Key type.
    type: str

    #: Number value.
    number: typing.Optional[float] = None

    #: String value.
    string: typing.Optional[str] = None

    #: Date value.
    date: typing.Optional[float] = None

    #: Array value.
    array: typing.Optional[typing.List['Key']] = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {
            'type': self.type,
        }
        if self.number is not None:
            json['number'] = self.number
        if self.string is not None:
            json['string'] = self.string
        if self.date is not None:
            json['date'] = self.date
        if self.array is not None:
            json['array'] = [i.to_json() for i in self.array]
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> 'Key':
        number = json['number'] if 'number' in json else None
        string = json['string'] if 'string' in json else None
        date = json['date'] if 'date' in json else None
        array = [Key.from_json(i) for i in json['array']] if 'array' in json else None
        return cls(
            type=json['type'],
            number=number,
            string=string,
            date=date,
            array=array,
        )

@dataclass
class KeyRange:
    '''
    Key range.
    '''
    #: If true lower bound is open.
    lower_open: bool

    #: If true upper bound is open.
    upper_open: bool

    #: Lower bound.
    lower: typing.Optional[Key] = None

    #: Upper bound.
    upper: typing.Optional[Key] = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {
            'lowerOpen': self.lower_open,
            'upperOpen': self.upper_open,
        }
        if self.lower is not None:
            json['lower'] = self.lower.to_json()
        if self.upper is not None:
            json['upper'] = self.upper.to_json()
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> 'KeyRange':
        lower = Key.from_json(json['lower']) if 'lower' in json else None
        upper = Key.from_json(json['upper']) if 'upper' in json else None
        return cls(
            lower=lower,
            upper=upper,
            lower_open=json['lowerOpen'],
            upper_open=json['upperOpen'],
        )

@dataclass
class DataEntry:
    '''
    Data entry.
    '''
    #: Key object.
    key: runtime.RemoteObject

    #: Primary key object.
    primary_key: runtime.RemoteObject

    #: Value object.
    value: runtime.RemoteObject

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {
            'key': self.key.to_json(),
            'primaryKey': self.primary_key.to_json(),
            'value': self.value.to_json(),
        }
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> 'DataEntry':
        return cls(
            key=runtime.RemoteObject.from_json(json['key']),
            primary_key=runtime.RemoteObject.from_json(json['primaryKey']),
            value=runtime.RemoteObject.from_json(json['value']),
        )

@dataclass
class KeyPath:
    '''
    Key path.
    '''
    #: Key path type.
    type: str

    #: String value.
    string: typing.Optional[str] = None

    #: Array value.
    array: typing.Optional[typing.List['str']] = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {
            'type': self.type,
        }
        if self.string is not None:
            json['string'] = self.string
        if self.array is not None:
            json['array'] = [i for i in self.array]
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> 'KeyPath':
        string = json['string'] if 'string' in json else None
        array = [i for i in json['array']] if 'array' in json else None
        return cls(
            type=json['type'],
            string=string,
            array=array,
        )

@dataclass
class ObjectStore:
    '''
    Object store.
    '''
    #: Object store name.
    name: str

    #: Object store key path.
    key_path: KeyPath

    #: If true, object store has auto increment flag set.
    auto_increment: bool

    #: Indexes in this object store.
    indexes: typing.List['ObjectStoreIndex']

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {
            'name': self.name,
            'keyPath': self.key_path.to_json(),
            'autoIncrement': self.auto_increment,
            'indexes': [i.to_json() for i in self.indexes],
        }
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> 'ObjectStore':
        return cls(
            name=json['name'],
            key_path=KeyPath.from_json(json['keyPath']),
            auto_increment=json['autoIncrement'],
            indexes=[ObjectStoreIndex.from_json(i) for i in json['indexes']],
        )

@dataclass
class ObjectStoreIndex:
    '''
    Object store index.
    '''
    #: Index name.
    name: str

    #: Index key path.
    key_path: KeyPath

    #: If true, index is unique.
    unique: bool

    #: If true, index allows multiple entries for a key.
    multi_entry: bool

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {
            'name': self.name,
            'keyPath': self.key_path.to_json(),
            'unique': self.unique,
            'multiEntry': self.multi_entry,
        }
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> 'ObjectStoreIndex':
        return cls(
            name=json['name'],
            key_path=KeyPath.from_json(json['keyPath']),
            unique=json['unique'],
            multi_entry=json['multiEntry'],
        )

