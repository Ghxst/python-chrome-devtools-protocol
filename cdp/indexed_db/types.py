'''
DO NOT EDIT THIS FILE

This file is generated from the CDP definitions. If you need to make changes,
edit the generator and regenerate all of the modules.

Domain: indexed_db
Experimental: True
'''

from dataclasses import dataclass, field
import typing

from ..runtime import types as runtime



@dataclass
class DatabaseWithObjectStores:
    '''
    Database with an array of object stores.
    '''
    #: Database name.
    name: str

    #: Database version (type is not 'integer', as the standard
    #: requires the version number to be 'unsigned long long')
    version: float

    #: Object stores in this database.
    object_stores: typing.List['ObjectStore']

    @classmethod
    def from_response(cls, response):
        return cls(
            name=str(response.get('name')),
            version=float(response.get('version')),
            object_stores=[ObjectStore.from_response(i) for i in response.get('objectStores')],
        )


@dataclass
class Key:
    '''
    Key.
    '''
    #: Key type.
    type_: str

    #: Number value.
    number: float

    #: String value.
    string: str

    #: Date value.
    date: float

    #: Array value.
    array: typing.List['Key']

    @classmethod
    def from_response(cls, response):
        return cls(
            type_=str(response.get('type')),
            number=float(response.get('number')),
            string=str(response.get('string')),
            date=float(response.get('date')),
            array=[Key.from_response(i) for i in response.get('array')],
        )


@dataclass
class KeyRange:
    '''
    Key range.
    '''
    #: Lower bound.
    lower: Key

    #: Upper bound.
    upper: Key

    #: If true lower bound is open.
    lower_open: bool

    #: If true upper bound is open.
    upper_open: bool

    @classmethod
    def from_response(cls, response):
        return cls(
            lower=Key.from_response(response.get('lower')),
            upper=Key.from_response(response.get('upper')),
            lower_open=bool(response.get('lowerOpen')),
            upper_open=bool(response.get('upperOpen')),
        )


@dataclass
class DataEntry:
    '''
    Data entry.
    '''
    #: Key object.
    key: runtime.RemoteObject

    #: Primary key object.
    primary_key: runtime.RemoteObject

    #: Value object.
    value: runtime.RemoteObject

    @classmethod
    def from_response(cls, response):
        return cls(
            key=runtime.RemoteObject.from_response(response.get('key')),
            primary_key=runtime.RemoteObject.from_response(response.get('primaryKey')),
            value=runtime.RemoteObject.from_response(response.get('value')),
        )


@dataclass
class KeyPath:
    '''
    Key path.
    '''
    #: Key path type.
    type_: str

    #: String value.
    string: str

    #: Array value.
    array: typing.List

    @classmethod
    def from_response(cls, response):
        return cls(
            type_=str(response.get('type')),
            string=str(response.get('string')),
            array=[str(i) for i in response.get('array')],
        )


@dataclass
class ObjectStore:
    '''
    Object store.
    '''
    #: Object store name.
    name: str

    #: Object store key path.
    key_path: KeyPath

    #: If true, object store has auto increment flag set.
    auto_increment: bool

    #: Indexes in this object store.
    indexes: typing.List['ObjectStoreIndex']

    @classmethod
    def from_response(cls, response):
        return cls(
            name=str(response.get('name')),
            key_path=KeyPath.from_response(response.get('keyPath')),
            auto_increment=bool(response.get('autoIncrement')),
            indexes=[ObjectStoreIndex.from_response(i) for i in response.get('indexes')],
        )


@dataclass
class ObjectStoreIndex:
    '''
    Object store index.
    '''
    #: Index name.
    name: str

    #: Index key path.
    key_path: KeyPath

    #: If true, index is unique.
    unique: bool

    #: If true, index allows multiple entries for a key.
    multi_entry: bool

    @classmethod
    def from_response(cls, response):
        return cls(
            name=str(response.get('name')),
            key_path=KeyPath.from_response(response.get('keyPath')),
            unique=bool(response.get('unique')),
            multi_entry=bool(response.get('multiEntry')),
        )

