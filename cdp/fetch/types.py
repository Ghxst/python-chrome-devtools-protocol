'''
DO NOT EDIT THIS FILE

This file is generated from the CDP definitions. If you need to make changes,
edit the generator and regenerate all of the modules.

Domain: fetch
Experimental: True
'''

from cdp.util import T_JSON_DICT
from dataclasses import dataclass
import enum
import typing

from ..network import types as network


class RequestId(str):
    '''
    Unique request identifier.
    '''
    def to_json(self) -> str:
        return self

    @classmethod
    def from_json(cls, json: str) -> 'RequestId':
        return cls(json)

    def __repr__(self):
        return 'RequestId({})'.format(super().__repr__())


class RequestStage(enum.Enum):
    '''
    Stages of the request to handle. Request will intercept before the request is
    sent. Response will intercept after the response is received (but before response
    body is received.
    '''
    REQUEST = "Request"
    RESPONSE = "Response"

    def to_json(self) -> str:
        return self.value

    @classmethod
    def from_json(cls, json: str) -> 'RequestStage':
        return cls(json)


@dataclass
class RequestPattern:
    #: Wildcards ('*' -> zero or more, '?' -> exactly one) are allowed. Escape character is
    #: backslash. Omitting is equivalent to "*".
    url_pattern: typing.Optional[str] = None

    #: If set, only requests for matching resource types will be intercepted.
    resource_type: typing.Optional[network.ResourceType] = None

    #: Stage at wich to begin intercepting requests. Default is Request.
    request_stage: typing.Optional[RequestStage] = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {
        }
        if self.url_pattern is not None:
            json['urlPattern'] = self.url_pattern
        if self.resource_type is not None:
            json['resourceType'] = self.resource_type.to_json()
        if self.request_stage is not None:
            json['requestStage'] = self.request_stage.to_json()
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> 'RequestPattern':
        url_pattern = json['urlPattern'] if 'urlPattern' in json else None
        resource_type = network.ResourceType.from_json(json['resourceType']) if 'resourceType' in json else None
        request_stage = RequestStage.from_json(json['requestStage']) if 'requestStage' in json else None
        return cls(
            url_pattern=url_pattern,
            resource_type=resource_type,
            request_stage=request_stage,
        )

@dataclass
class HeaderEntry:
    '''
    Response HTTP header entry
    '''
    name: str

    value: str

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {
            'name': self.name,
            'value': self.value,
        }
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> 'HeaderEntry':
        return cls(
            name=json['name'],
            value=json['value'],
        )

@dataclass
class AuthChallenge:
    '''
    Authorization challenge for HTTP status code 401 or 407.
    '''
    #: Origin of the challenger.
    origin: str

    #: The authentication scheme used, such as basic or digest
    scheme: str

    #: The realm of the challenge. May be empty.
    realm: str

    #: Source of the authentication challenge.
    source: typing.Optional[str] = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {
            'origin': self.origin,
            'scheme': self.scheme,
            'realm': self.realm,
        }
        if self.source is not None:
            json['source'] = self.source
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> 'AuthChallenge':
        source = json['source'] if 'source' in json else None
        return cls(
            source=source,
            origin=json['origin'],
            scheme=json['scheme'],
            realm=json['realm'],
        )

@dataclass
class AuthChallengeResponse:
    '''
    Response to an AuthChallenge.
    '''
    #: The decision on what to do in response to the authorization challenge.  Default means
    #: deferring to the default behavior of the net stack, which will likely either the Cancel
    #: authentication or display a popup dialog box.
    response: str

    #: The username to provide, possibly empty. Should only be set if response is
    #: ProvideCredentials.
    username: typing.Optional[str] = None

    #: The password to provide, possibly empty. Should only be set if response is
    #: ProvideCredentials.
    password: typing.Optional[str] = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {
            'response': self.response,
        }
        if self.username is not None:
            json['username'] = self.username
        if self.password is not None:
            json['password'] = self.password
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> 'AuthChallengeResponse':
        username = json['username'] if 'username' in json else None
        password = json['password'] if 'password' in json else None
        return cls(
            response=json['response'],
            username=username,
            password=password,
        )

