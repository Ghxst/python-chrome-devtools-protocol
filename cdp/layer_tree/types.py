'''
DO NOT EDIT THIS FILE

This file is generated from the CDP definitions. If you need to make changes,
edit the generator and regenerate all of the modules.

Domain: layer_tree
Experimental: True
'''

from dataclasses import dataclass, field
import typing

from ..dom import types as dom


class LayerId(str):
    '''
    Unique Layer identifier.
    '''
    @classmethod
    def from_response(cls, response):
        return cls(response)

    def __repr__(self):
        return 'LayerId({})'.format(str.__repr__(self))


class SnapshotId(str):
    '''
    Unique snapshot identifier.
    '''
    @classmethod
    def from_response(cls, response):
        return cls(response)

    def __repr__(self):
        return 'SnapshotId({})'.format(str.__repr__(self))


class PaintProfile(typing.List):
    '''
    Array of timings, one per paint step.
    '''
    @classmethod
    def from_response(cls, response):
        return cls(response)

    def __repr__(self):
        return 'PaintProfile({})'.format(typing.List.__repr__(self))



@dataclass
class ScrollRect:
    '''
    Rectangle where scrolling happens on the main thread.
    '''
    #: Rectangle itself.
    rect: dom.Rect

    #: Reason for rectangle to force scrolling on the main thread
    type_: str

    @classmethod
    def from_response(cls, response):
        return cls(
            rect=dom.Rect.from_response(response.get('rect')),
            type_=str(response.get('type')),
        )


@dataclass
class StickyPositionConstraint:
    '''
    Sticky position constraints.
    '''
    #: Layout rectangle of the sticky element before being shifted
    sticky_box_rect: dom.Rect

    #: Layout rectangle of the containing block of the sticky element
    containing_block_rect: dom.Rect

    #: The nearest sticky layer that shifts the sticky box
    nearest_layer_shifting_sticky_box: LayerId

    #: The nearest sticky layer that shifts the containing block
    nearest_layer_shifting_containing_block: LayerId

    @classmethod
    def from_response(cls, response):
        return cls(
            sticky_box_rect=dom.Rect.from_response(response.get('stickyBoxRect')),
            containing_block_rect=dom.Rect.from_response(response.get('containingBlockRect')),
            nearest_layer_shifting_sticky_box=LayerId.from_response(response.get('nearestLayerShiftingStickyBox')),
            nearest_layer_shifting_containing_block=LayerId.from_response(response.get('nearestLayerShiftingContainingBlock')),
        )


@dataclass
class PictureTile:
    '''
    Serialized fragment of layer picture along with its offset within the layer.
    '''
    #: Offset from owning layer left boundary
    x: float

    #: Offset from owning layer top boundary
    y: float

    #: Base64-encoded snapshot data.
    picture: str

    @classmethod
    def from_response(cls, response):
        return cls(
            x=float(response.get('x')),
            y=float(response.get('y')),
            picture=str(response.get('picture')),
        )


@dataclass
class Layer:
    '''
    Information about a compositing layer.
    '''
    #: The unique id for this layer.
    layer_id: LayerId

    #: The id of parent (not present for root).
    parent_layer_id: LayerId

    #: The backend id for the node associated with this layer.
    backend_node_id: dom.BackendNodeId

    #: Offset from parent layer, X coordinate.
    offset_x: float

    #: Offset from parent layer, Y coordinate.
    offset_y: float

    #: Layer width.
    width: float

    #: Layer height.
    height: float

    #: Transformation matrix for layer, default is identity matrix
    transform: typing.List

    #: Transform anchor point X, absent if no transform specified
    anchor_x: float

    #: Transform anchor point Y, absent if no transform specified
    anchor_y: float

    #: Transform anchor point Z, absent if no transform specified
    anchor_z: float

    #: Indicates how many time this layer has painted.
    paint_count: int

    #: Indicates whether this layer hosts any content, rather than being used for
    #: transform/scrolling purposes only.
    draws_content: bool

    #: Set if layer is not visible.
    invisible: bool

    #: Rectangles scrolling on main thread only.
    scroll_rects: typing.List['ScrollRect']

    #: Sticky position constraint information
    sticky_position_constraint: StickyPositionConstraint

    @classmethod
    def from_response(cls, response):
        return cls(
            layer_id=LayerId.from_response(response.get('layerId')),
            parent_layer_id=LayerId.from_response(response.get('parentLayerId')),
            backend_node_id=dom.BackendNodeId.from_response(response.get('backendNodeId')),
            offset_x=float(response.get('offsetX')),
            offset_y=float(response.get('offsetY')),
            width=float(response.get('width')),
            height=float(response.get('height')),
            transform=[float(i) for i in response.get('transform')],
            anchor_x=float(response.get('anchorX')),
            anchor_y=float(response.get('anchorY')),
            anchor_z=float(response.get('anchorZ')),
            paint_count=int(response.get('paintCount')),
            draws_content=bool(response.get('drawsContent')),
            invisible=bool(response.get('invisible')),
            scroll_rects=[ScrollRect.from_response(i) for i in response.get('scrollRects')],
            sticky_position_constraint=StickyPositionConstraint.from_response(response.get('stickyPositionConstraint')),
        )

