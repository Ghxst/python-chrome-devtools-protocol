'''
DO NOT EDIT THIS FILE

This file is generated from the CDP definitions. If you need to make changes,
edit the generator and regenerate all of the modules.

Domain: debugger
Experimental: False
'''

from cdp.util import T_JSON_DICT
from dataclasses import dataclass
import enum
import typing

from .types import *
from ..runtime import types as runtime



@dataclass
class BreakpointResolved:
    '''
    Fired when breakpoint is resolved to an actual script and location.
    '''
    #: Fired when breakpoint is resolved to an actual script and location.
    breakpoint_id: BreakpointId

    #: Fired when breakpoint is resolved to an actual script and location.
    location: Location

    # These fields are used for internal purposes and are not part of CDP
    _domain = 'Debugger'
    _method = 'breakpointResolved'

    @classmethod
    def from_json(cls, json: dict) -> 'BreakpointResolved':
        return cls(
            breakpoint_id=BreakpointId.from_json(json['breakpointId']),
            location=Location.from_json(json['location']),
        )


@dataclass
class Paused:
    '''
    Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.
    '''
    #: Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.
    call_frames: typing.List['CallFrame']

    #: Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.
    reason: str

    #: Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.
    data: typing.Optional[dict] = None

    #: Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.
    hit_breakpoints: typing.Optional[typing.List['str']] = None

    #: Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.
    async_stack_trace: typing.Optional[runtime.StackTrace] = None

    #: Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.
    async_stack_trace_id: typing.Optional[runtime.StackTraceId] = None

    #: Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.
    async_call_stack_trace_id: typing.Optional[runtime.StackTraceId] = None

    # These fields are used for internal purposes and are not part of CDP
    _domain = 'Debugger'
    _method = 'paused'

    @classmethod
    def from_json(cls, json: dict) -> 'Paused':
        data = dict(json['data']) if 'data' in json else None
        hit_breakpoints = [str(i) for i in json['hitBreakpoints']] if 'hitBreakpoints' in json else None
        async_stack_trace = runtime.StackTrace.from_json(json['asyncStackTrace']) if 'asyncStackTrace' in json else None
        async_stack_trace_id = runtime.StackTraceId.from_json(json['asyncStackTraceId']) if 'asyncStackTraceId' in json else None
        async_call_stack_trace_id = runtime.StackTraceId.from_json(json['asyncCallStackTraceId']) if 'asyncCallStackTraceId' in json else None
        return cls(
            call_frames=[CallFrame.from_json(i) for i in json['callFrames']],
            reason=str(json['reason']),
            data=data,
            hit_breakpoints=hit_breakpoints,
            async_stack_trace=async_stack_trace,
            async_stack_trace_id=async_stack_trace_id,
            async_call_stack_trace_id=async_call_stack_trace_id,
        )


@dataclass
class Resumed:
    '''
    Fired when the virtual machine resumed execution.
    '''
    # These fields are used for internal purposes and are not part of CDP
    _domain = 'Debugger'
    _method = 'resumed'

    @classmethod
    def from_json(cls, json: dict) -> 'Resumed':
        return cls(
        )


@dataclass
class ScriptFailedToParse:
    '''
    Fired when virtual machine fails to parse the script.
    '''
    #: Fired when virtual machine fails to parse the script.
    script_id: runtime.ScriptId

    #: Fired when virtual machine fails to parse the script.
    url: str

    #: Fired when virtual machine fails to parse the script.
    start_line: int

    #: Fired when virtual machine fails to parse the script.
    start_column: int

    #: Fired when virtual machine fails to parse the script.
    end_line: int

    #: Fired when virtual machine fails to parse the script.
    end_column: int

    #: Fired when virtual machine fails to parse the script.
    execution_context_id: runtime.ExecutionContextId

    #: Fired when virtual machine fails to parse the script.
    hash: str

    #: Fired when virtual machine fails to parse the script.
    execution_context_aux_data: typing.Optional[dict] = None

    #: Fired when virtual machine fails to parse the script.
    source_map_url: typing.Optional[str] = None

    #: Fired when virtual machine fails to parse the script.
    has_source_url: typing.Optional[bool] = None

    #: Fired when virtual machine fails to parse the script.
    is_module: typing.Optional[bool] = None

    #: Fired when virtual machine fails to parse the script.
    length: typing.Optional[int] = None

    #: Fired when virtual machine fails to parse the script.
    stack_trace: typing.Optional[runtime.StackTrace] = None

    # These fields are used for internal purposes and are not part of CDP
    _domain = 'Debugger'
    _method = 'scriptFailedToParse'

    @classmethod
    def from_json(cls, json: dict) -> 'ScriptFailedToParse':
        execution_context_aux_data = dict(json['executionContextAuxData']) if 'executionContextAuxData' in json else None
        source_map_url = str(json['sourceMapURL']) if 'sourceMapURL' in json else None
        has_source_url = bool(json['hasSourceURL']) if 'hasSourceURL' in json else None
        is_module = bool(json['isModule']) if 'isModule' in json else None
        length = int(json['length']) if 'length' in json else None
        stack_trace = runtime.StackTrace.from_json(json['stackTrace']) if 'stackTrace' in json else None
        return cls(
            script_id=runtime.ScriptId.from_json(json['scriptId']),
            url=str(json['url']),
            start_line=int(json['startLine']),
            start_column=int(json['startColumn']),
            end_line=int(json['endLine']),
            end_column=int(json['endColumn']),
            execution_context_id=runtime.ExecutionContextId.from_json(json['executionContextId']),
            hash=str(json['hash']),
            execution_context_aux_data=execution_context_aux_data,
            source_map_url=source_map_url,
            has_source_url=has_source_url,
            is_module=is_module,
            length=length,
            stack_trace=stack_trace,
        )


@dataclass
class ScriptParsed:
    '''
    Fired when virtual machine parses script. This event is also fired for all known and uncollected
    scripts upon enabling debugger.
    '''
    #: Fired when virtual machine parses script. This event is also fired for all known and uncollected
    #: scripts upon enabling debugger.
    script_id: runtime.ScriptId

    #: Fired when virtual machine parses script. This event is also fired for all known and uncollected
    #: scripts upon enabling debugger.
    url: str

    #: Fired when virtual machine parses script. This event is also fired for all known and uncollected
    #: scripts upon enabling debugger.
    start_line: int

    #: Fired when virtual machine parses script. This event is also fired for all known and uncollected
    #: scripts upon enabling debugger.
    start_column: int

    #: Fired when virtual machine parses script. This event is also fired for all known and uncollected
    #: scripts upon enabling debugger.
    end_line: int

    #: Fired when virtual machine parses script. This event is also fired for all known and uncollected
    #: scripts upon enabling debugger.
    end_column: int

    #: Fired when virtual machine parses script. This event is also fired for all known and uncollected
    #: scripts upon enabling debugger.
    execution_context_id: runtime.ExecutionContextId

    #: Fired when virtual machine parses script. This event is also fired for all known and uncollected
    #: scripts upon enabling debugger.
    hash: str

    #: Fired when virtual machine parses script. This event is also fired for all known and uncollected
    #: scripts upon enabling debugger.
    execution_context_aux_data: typing.Optional[dict] = None

    #: Fired when virtual machine parses script. This event is also fired for all known and uncollected
    #: scripts upon enabling debugger.
    is_live_edit: typing.Optional[bool] = None

    #: Fired when virtual machine parses script. This event is also fired for all known and uncollected
    #: scripts upon enabling debugger.
    source_map_url: typing.Optional[str] = None

    #: Fired when virtual machine parses script. This event is also fired for all known and uncollected
    #: scripts upon enabling debugger.
    has_source_url: typing.Optional[bool] = None

    #: Fired when virtual machine parses script. This event is also fired for all known and uncollected
    #: scripts upon enabling debugger.
    is_module: typing.Optional[bool] = None

    #: Fired when virtual machine parses script. This event is also fired for all known and uncollected
    #: scripts upon enabling debugger.
    length: typing.Optional[int] = None

    #: Fired when virtual machine parses script. This event is also fired for all known and uncollected
    #: scripts upon enabling debugger.
    stack_trace: typing.Optional[runtime.StackTrace] = None

    # These fields are used for internal purposes and are not part of CDP
    _domain = 'Debugger'
    _method = 'scriptParsed'

    @classmethod
    def from_json(cls, json: dict) -> 'ScriptParsed':
        execution_context_aux_data = dict(json['executionContextAuxData']) if 'executionContextAuxData' in json else None
        is_live_edit = bool(json['isLiveEdit']) if 'isLiveEdit' in json else None
        source_map_url = str(json['sourceMapURL']) if 'sourceMapURL' in json else None
        has_source_url = bool(json['hasSourceURL']) if 'hasSourceURL' in json else None
        is_module = bool(json['isModule']) if 'isModule' in json else None
        length = int(json['length']) if 'length' in json else None
        stack_trace = runtime.StackTrace.from_json(json['stackTrace']) if 'stackTrace' in json else None
        return cls(
            script_id=runtime.ScriptId.from_json(json['scriptId']),
            url=str(json['url']),
            start_line=int(json['startLine']),
            start_column=int(json['startColumn']),
            end_line=int(json['endLine']),
            end_column=int(json['endColumn']),
            execution_context_id=runtime.ExecutionContextId.from_json(json['executionContextId']),
            hash=str(json['hash']),
            execution_context_aux_data=execution_context_aux_data,
            is_live_edit=is_live_edit,
            source_map_url=source_map_url,
            has_source_url=has_source_url,
            is_module=is_module,
            length=length,
            stack_trace=stack_trace,
        )

