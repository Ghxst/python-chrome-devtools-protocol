'''
DO NOT EDIT THIS FILE

This file is generated from the CDP definitions. If you need to make changes,
edit the generator and regenerate all of the modules.

Domain: debugger
Experimental: False
'''

from cdp.util import T_JSON_DICT
from dataclasses import dataclass
import enum
import typing

from .types import *
from ..runtime import types as runtime



@dataclass
class BreakpointResolved:
    '''
    Fired when breakpoint is resolved to an actual script and location.
    '''
    #: Fired when breakpoint is resolved to an actual script and location.
    breakpoint_id: BreakpointId

    #: Fired when breakpoint is resolved to an actual script and location.
    location: Location

    # These fields are used for internal purposes and are not part of CDP
    _domain = 'Debugger'
    _method = 'breakpointResolved'

    @classmethod
    def from_json(cls, json: dict) -> 'BreakpointResolved':
        return cls(
            breakpoint_id=BreakpointId.from_json(json['breakpointId']),
            location=Location.from_json(json['location']),
        )


@dataclass
class Paused:
    '''
    Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.
    '''
    #: Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.
    call_frames: typing.List['CallFrame']

    #: Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.
    reason: str

    #: Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.
    data: dict

    #: Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.
    hit_breakpoints: typing.List['str']

    #: Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.
    async_stack_trace: runtime.StackTrace

    #: Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.
    async_stack_trace_id: runtime.StackTraceId

    #: Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.
    async_call_stack_trace_id: runtime.StackTraceId

    # These fields are used for internal purposes and are not part of CDP
    _domain = 'Debugger'
    _method = 'paused'

    @classmethod
    def from_json(cls, json: dict) -> 'Paused':
        return cls(
            call_frames=[CallFrame.from_json(i) for i in json['callFrames']],
            reason=str(json['reason']),
            data=dict(json['data']),
            hit_breakpoints=[str(i) for i in json['hitBreakpoints']],
            async_stack_trace=runtime.StackTrace.from_json(json['asyncStackTrace']),
            async_stack_trace_id=runtime.StackTraceId.from_json(json['asyncStackTraceId']),
            async_call_stack_trace_id=runtime.StackTraceId.from_json(json['asyncCallStackTraceId']),
        )


@dataclass
class Resumed:
    '''
    Fired when the virtual machine resumed execution.
    '''
    # These fields are used for internal purposes and are not part of CDP
    _domain = 'Debugger'
    _method = 'resumed'

    @classmethod
    def from_json(cls, json: dict) -> 'Resumed':
        return cls(
        )


@dataclass
class ScriptFailedToParse:
    '''
    Fired when virtual machine fails to parse the script.
    '''
    #: Fired when virtual machine fails to parse the script.
    script_id: runtime.ScriptId

    #: Fired when virtual machine fails to parse the script.
    url: str

    #: Fired when virtual machine fails to parse the script.
    start_line: int

    #: Fired when virtual machine fails to parse the script.
    start_column: int

    #: Fired when virtual machine fails to parse the script.
    end_line: int

    #: Fired when virtual machine fails to parse the script.
    end_column: int

    #: Fired when virtual machine fails to parse the script.
    execution_context_id: runtime.ExecutionContextId

    #: Fired when virtual machine fails to parse the script.
    hash: str

    #: Fired when virtual machine fails to parse the script.
    execution_context_aux_data: dict

    #: Fired when virtual machine fails to parse the script.
    source_map_url: str

    #: Fired when virtual machine fails to parse the script.
    has_source_url: bool

    #: Fired when virtual machine fails to parse the script.
    is_module: bool

    #: Fired when virtual machine fails to parse the script.
    length: int

    #: Fired when virtual machine fails to parse the script.
    stack_trace: runtime.StackTrace

    # These fields are used for internal purposes and are not part of CDP
    _domain = 'Debugger'
    _method = 'scriptFailedToParse'

    @classmethod
    def from_json(cls, json: dict) -> 'ScriptFailedToParse':
        return cls(
            script_id=runtime.ScriptId.from_json(json['scriptId']),
            url=str(json['url']),
            start_line=int(json['startLine']),
            start_column=int(json['startColumn']),
            end_line=int(json['endLine']),
            end_column=int(json['endColumn']),
            execution_context_id=runtime.ExecutionContextId.from_json(json['executionContextId']),
            hash=str(json['hash']),
            execution_context_aux_data=dict(json['executionContextAuxData']),
            source_map_url=str(json['sourceMapURL']),
            has_source_url=bool(json['hasSourceURL']),
            is_module=bool(json['isModule']),
            length=int(json['length']),
            stack_trace=runtime.StackTrace.from_json(json['stackTrace']),
        )


@dataclass
class ScriptParsed:
    '''
    Fired when virtual machine parses script. This event is also fired for all known and uncollected
    scripts upon enabling debugger.
    '''
    #: Fired when virtual machine parses script. This event is also fired for all known and uncollected
    #: scripts upon enabling debugger.
    script_id: runtime.ScriptId

    #: Fired when virtual machine parses script. This event is also fired for all known and uncollected
    #: scripts upon enabling debugger.
    url: str

    #: Fired when virtual machine parses script. This event is also fired for all known and uncollected
    #: scripts upon enabling debugger.
    start_line: int

    #: Fired when virtual machine parses script. This event is also fired for all known and uncollected
    #: scripts upon enabling debugger.
    start_column: int

    #: Fired when virtual machine parses script. This event is also fired for all known and uncollected
    #: scripts upon enabling debugger.
    end_line: int

    #: Fired when virtual machine parses script. This event is also fired for all known and uncollected
    #: scripts upon enabling debugger.
    end_column: int

    #: Fired when virtual machine parses script. This event is also fired for all known and uncollected
    #: scripts upon enabling debugger.
    execution_context_id: runtime.ExecutionContextId

    #: Fired when virtual machine parses script. This event is also fired for all known and uncollected
    #: scripts upon enabling debugger.
    hash: str

    #: Fired when virtual machine parses script. This event is also fired for all known and uncollected
    #: scripts upon enabling debugger.
    execution_context_aux_data: dict

    #: Fired when virtual machine parses script. This event is also fired for all known and uncollected
    #: scripts upon enabling debugger.
    is_live_edit: bool

    #: Fired when virtual machine parses script. This event is also fired for all known and uncollected
    #: scripts upon enabling debugger.
    source_map_url: str

    #: Fired when virtual machine parses script. This event is also fired for all known and uncollected
    #: scripts upon enabling debugger.
    has_source_url: bool

    #: Fired when virtual machine parses script. This event is also fired for all known and uncollected
    #: scripts upon enabling debugger.
    is_module: bool

    #: Fired when virtual machine parses script. This event is also fired for all known and uncollected
    #: scripts upon enabling debugger.
    length: int

    #: Fired when virtual machine parses script. This event is also fired for all known and uncollected
    #: scripts upon enabling debugger.
    stack_trace: runtime.StackTrace

    # These fields are used for internal purposes and are not part of CDP
    _domain = 'Debugger'
    _method = 'scriptParsed'

    @classmethod
    def from_json(cls, json: dict) -> 'ScriptParsed':
        return cls(
            script_id=runtime.ScriptId.from_json(json['scriptId']),
            url=str(json['url']),
            start_line=int(json['startLine']),
            start_column=int(json['startColumn']),
            end_line=int(json['endLine']),
            end_column=int(json['endColumn']),
            execution_context_id=runtime.ExecutionContextId.from_json(json['executionContextId']),
            hash=str(json['hash']),
            execution_context_aux_data=dict(json['executionContextAuxData']),
            is_live_edit=bool(json['isLiveEdit']),
            source_map_url=str(json['sourceMapURL']),
            has_source_url=bool(json['hasSourceURL']),
            is_module=bool(json['isModule']),
            length=int(json['length']),
            stack_trace=runtime.StackTrace.from_json(json['stackTrace']),
        )

