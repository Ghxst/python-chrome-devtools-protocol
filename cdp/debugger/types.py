'''
DO NOT EDIT THIS FILE

This file is generated from the CDP definitions. If you need to make changes,
edit the generator and regenerate all of the modules.

Domain: debugger
Experimental: False
'''

from dataclasses import dataclass, field
import typing

from ..runtime import types as runtime


class BreakpointId(str):
    '''
    Breakpoint identifier.
    '''
    @classmethod
    def from_response(cls, response):
        return cls(response)

    def __repr__(self):
        return 'BreakpointId({})'.format(str.__repr__(self))


class CallFrameId(str):
    '''
    Call frame identifier.
    '''
    @classmethod
    def from_response(cls, response):
        return cls(response)

    def __repr__(self):
        return 'CallFrameId({})'.format(str.__repr__(self))



@dataclass
class Location:
    '''
    Location in the source code.
    '''
    #: Script identifier as reported in the `Debugger.scriptParsed`.
    script_id: runtime.ScriptId

    #: Line number in the script (0-based).
    line_number: int

    #: Column number in the script (0-based).
    column_number: int

    @classmethod
    def from_response(cls, response):
        return cls(
            script_id=runtime.ScriptId.from_response(response.get('scriptId')),
            line_number=int(response.get('lineNumber')),
            column_number=int(response.get('columnNumber')),
        )


@dataclass
class ScriptPosition:
    '''
    Location in the source code.
    '''
    line_number: int

    column_number: int

    @classmethod
    def from_response(cls, response):
        return cls(
            line_number=int(response.get('lineNumber')),
            column_number=int(response.get('columnNumber')),
        )


@dataclass
class CallFrame:
    '''
    JavaScript call frame. Array of call frames form the call stack.
    '''
    #: Call frame identifier. This identifier is only valid while the virtual machine is paused.
    call_frame_id: CallFrameId

    #: Name of the JavaScript function called on this call frame.
    function_name: str

    #: Location in the source code.
    function_location: Location

    #: Location in the source code.
    location: Location

    #: JavaScript script name or url.
    url: str

    #: Scope chain for this call frame.
    scope_chain: typing.List['Scope']

    #: `this` object for this call frame.
    this: runtime.RemoteObject

    #: The value being returned, if the function is at return point.
    return_value: runtime.RemoteObject

    @classmethod
    def from_response(cls, response):
        return cls(
            call_frame_id=CallFrameId.from_response(response.get('callFrameId')),
            function_name=str(response.get('functionName')),
            function_location=Location.from_response(response.get('functionLocation')),
            location=Location.from_response(response.get('location')),
            url=str(response.get('url')),
            scope_chain=[Scope.from_response(i) for i in response.get('scopeChain')],
            this=runtime.RemoteObject.from_response(response.get('this')),
            return_value=runtime.RemoteObject.from_response(response.get('returnValue')),
        )


@dataclass
class Scope:
    '''
    Scope description.
    '''
    #: Scope type.
    type_: str

    #: Object representing the scope. For `global` and `with` scopes it represents the actual
    #: object; for the rest of the scopes, it is artificial transient object enumerating scope
    #: variables as its properties.
    object: runtime.RemoteObject

    name: str

    #: Location in the source code where scope starts
    start_location: Location

    #: Location in the source code where scope ends
    end_location: Location

    @classmethod
    def from_response(cls, response):
        return cls(
            type_=str(response.get('type')),
            object=runtime.RemoteObject.from_response(response.get('object')),
            name=str(response.get('name')),
            start_location=Location.from_response(response.get('startLocation')),
            end_location=Location.from_response(response.get('endLocation')),
        )


@dataclass
class SearchMatch:
    '''
    Search match for resource.
    '''
    #: Line number in resource content.
    line_number: float

    #: Line with match content.
    line_content: str

    @classmethod
    def from_response(cls, response):
        return cls(
            line_number=float(response.get('lineNumber')),
            line_content=str(response.get('lineContent')),
        )


@dataclass
class BreakLocation:
    #: Script identifier as reported in the `Debugger.scriptParsed`.
    script_id: runtime.ScriptId

    #: Line number in the script (0-based).
    line_number: int

    #: Column number in the script (0-based).
    column_number: int

    type_: str

    @classmethod
    def from_response(cls, response):
        return cls(
            script_id=runtime.ScriptId.from_response(response.get('scriptId')),
            line_number=int(response.get('lineNumber')),
            column_number=int(response.get('columnNumber')),
            type_=str(response.get('type')),
        )

