'''
DO NOT EDIT THIS FILE

This file is generated from the CDP definitions. If you need to make changes,
edit the generator and regenerate all of the modules.

Domain: dom_snapshot
Experimental: True
'''

from dataclasses import dataclass, field
import typing

from ..dom import types as dom
from ..dom_debugger import types as dom_debugger
from ..page import types as page


class StringIndex(int):
    '''
    Index of the string in the strings table.
    '''
    @classmethod
    def from_response(cls, response):
        return cls(response)

    def __repr__(self):
        return 'StringIndex({})'.format(int.__repr__(self))


class ArrayOfStrings(typing.List['StringIndex']):
    '''
    Index of the string in the strings table.
    '''
    @classmethod
    def from_response(cls, response):
        return cls(response)

    def __repr__(self):
        return 'ArrayOfStrings({})'.format(typing.List['StringIndex'].__repr__(self))


class Rectangle(typing.List):
    @classmethod
    def from_response(cls, response):
        return cls(response)

    def __repr__(self):
        return 'Rectangle({})'.format(typing.List.__repr__(self))



@dataclass
class DOMNode:
    '''
    A Node in the DOM tree.
    '''
    #: `Node`'s nodeType.
    node_type: int

    #: `Node`'s nodeName.
    node_name: str

    #: `Node`'s nodeValue.
    node_value: str

    #: Only set for textarea elements, contains the text value.
    text_value: str

    #: Only set for input elements, contains the input's associated text value.
    input_value: str

    #: Only set for radio and checkbox input elements, indicates if the element has been checked
    input_checked: bool

    #: Only set for option elements, indicates if the element has been selected
    option_selected: bool

    #: `Node`'s id, corresponds to DOM.Node.backendNodeId.
    backend_node_id: dom.BackendNodeId

    #: The indexes of the node's child nodes in the `domNodes` array returned by `getSnapshot`, if
    #: any.
    child_node_indexes: typing.List

    #: Attributes of an `Element` node.
    attributes: typing.List['NameValue']

    #: Indexes of pseudo elements associated with this node in the `domNodes` array returned by
    #: `getSnapshot`, if any.
    pseudo_element_indexes: typing.List

    #: The index of the node's related layout tree node in the `layoutTreeNodes` array returned by
    #: `getSnapshot`, if any.
    layout_node_index: int

    #: Document URL that `Document` or `FrameOwner` node points to.
    document_url: str

    #: Base URL that `Document` or `FrameOwner` node uses for URL completion.
    base_url: str

    #: Only set for documents, contains the document's content language.
    content_language: str

    #: Only set for documents, contains the document's character set encoding.
    document_encoding: str

    #: `DocumentType` node's publicId.
    public_id: str

    #: `DocumentType` node's systemId.
    system_id: str

    #: Frame ID for frame owner elements and also for the document node.
    frame_id: page.FrameId

    #: The index of a frame owner element's content document in the `domNodes` array returned by
    #: `getSnapshot`, if any.
    content_document_index: int

    #: Type of a pseudo element node.
    pseudo_type: dom.PseudoType

    #: Shadow root type.
    shadow_root_type: dom.ShadowRootType

    #: Whether this DOM node responds to mouse clicks. This includes nodes that have had click
    #: event listeners attached via JavaScript as well as anchor tags that naturally navigate when
    #: clicked.
    is_clickable: bool

    #: Details of the node's event listeners, if any.
    event_listeners: typing.List['dom_debugger.EventListener']

    #: The selected url for nodes with a srcset attribute.
    current_source_url: str

    #: The url of the script (if any) that generates this node.
    origin_url: str

    #: Scroll offsets, set when this node is a Document.
    scroll_offset_x: float

    scroll_offset_y: float

    @classmethod
    def from_response(cls, response):
        return cls(
            node_type=int(response.get('nodeType')),
            node_name=str(response.get('nodeName')),
            node_value=str(response.get('nodeValue')),
            text_value=str(response.get('textValue')),
            input_value=str(response.get('inputValue')),
            input_checked=bool(response.get('inputChecked')),
            option_selected=bool(response.get('optionSelected')),
            backend_node_id=dom.BackendNodeId.from_response(response.get('backendNodeId')),
            child_node_indexes=[int(i) for i in response.get('childNodeIndexes')],
            attributes=[NameValue.from_response(i) for i in response.get('attributes')],
            pseudo_element_indexes=[int(i) for i in response.get('pseudoElementIndexes')],
            layout_node_index=int(response.get('layoutNodeIndex')),
            document_url=str(response.get('documentURL')),
            base_url=str(response.get('baseURL')),
            content_language=str(response.get('contentLanguage')),
            document_encoding=str(response.get('documentEncoding')),
            public_id=str(response.get('publicId')),
            system_id=str(response.get('systemId')),
            frame_id=page.FrameId.from_response(response.get('frameId')),
            content_document_index=int(response.get('contentDocumentIndex')),
            pseudo_type=dom.PseudoType.from_response(response.get('pseudoType')),
            shadow_root_type=dom.ShadowRootType.from_response(response.get('shadowRootType')),
            is_clickable=bool(response.get('isClickable')),
            event_listeners=[dom_debugger.EventListener.from_response(i) for i in response.get('eventListeners')],
            current_source_url=str(response.get('currentSourceURL')),
            origin_url=str(response.get('originURL')),
            scroll_offset_x=float(response.get('scrollOffsetX')),
            scroll_offset_y=float(response.get('scrollOffsetY')),
        )


@dataclass
class InlineTextBox:
    '''
    Details of post layout rendered text positions. The exact layout should not be regarded as
    stable and may change between versions.
    '''
    #: The bounding box in document coordinates. Note that scroll offset of the document is ignored.
    bounding_box: dom.Rect

    #: The starting index in characters, for this post layout textbox substring. Characters that
    #: would be represented as a surrogate pair in UTF-16 have length 2.
    start_character_index: int

    #: The number of characters in this post layout textbox substring. Characters that would be
    #: represented as a surrogate pair in UTF-16 have length 2.
    num_characters: int

    @classmethod
    def from_response(cls, response):
        return cls(
            bounding_box=dom.Rect.from_response(response.get('boundingBox')),
            start_character_index=int(response.get('startCharacterIndex')),
            num_characters=int(response.get('numCharacters')),
        )


@dataclass
class LayoutTreeNode:
    '''
    Details of an element in the DOM tree with a LayoutObject.
    '''
    #: The index of the related DOM node in the `domNodes` array returned by `getSnapshot`.
    dom_node_index: int

    #: The bounding box in document coordinates. Note that scroll offset of the document is ignored.
    bounding_box: dom.Rect

    #: Contents of the LayoutText, if any.
    layout_text: str

    #: The post-layout inline text nodes, if any.
    inline_text_nodes: typing.List['InlineTextBox']

    #: Index into the `computedStyles` array returned by `getSnapshot`.
    style_index: int

    #: Global paint order index, which is determined by the stacking order of the nodes. Nodes
    #: that are painted together will have the same index. Only provided if includePaintOrder in
    #: getSnapshot was true.
    paint_order: int

    #: Set to true to indicate the element begins a new stacking context.
    is_stacking_context: bool

    @classmethod
    def from_response(cls, response):
        return cls(
            dom_node_index=int(response.get('domNodeIndex')),
            bounding_box=dom.Rect.from_response(response.get('boundingBox')),
            layout_text=str(response.get('layoutText')),
            inline_text_nodes=[InlineTextBox.from_response(i) for i in response.get('inlineTextNodes')],
            style_index=int(response.get('styleIndex')),
            paint_order=int(response.get('paintOrder')),
            is_stacking_context=bool(response.get('isStackingContext')),
        )


@dataclass
class ComputedStyle:
    '''
    A subset of the full ComputedStyle as defined by the request whitelist.
    '''
    #: Name/value pairs of computed style properties.
    properties: typing.List['NameValue']

    @classmethod
    def from_response(cls, response):
        return cls(
            properties=[NameValue.from_response(i) for i in response.get('properties')],
        )


@dataclass
class NameValue:
    '''
    A name/value pair.
    '''
    #: Attribute/property name.
    name: str

    #: Attribute/property value.
    value: str

    @classmethod
    def from_response(cls, response):
        return cls(
            name=str(response.get('name')),
            value=str(response.get('value')),
        )


@dataclass
class RareStringData:
    '''
    Data that is only present on rare nodes.
    '''
    index: typing.List

    value: typing.List['StringIndex']

    @classmethod
    def from_response(cls, response):
        return cls(
            index=[int(i) for i in response.get('index')],
            value=[StringIndex.from_response(i) for i in response.get('value')],
        )


@dataclass
class RareBooleanData:
    index: typing.List

    @classmethod
    def from_response(cls, response):
        return cls(
            index=[int(i) for i in response.get('index')],
        )


@dataclass
class RareIntegerData:
    index: typing.List

    value: typing.List

    @classmethod
    def from_response(cls, response):
        return cls(
            index=[int(i) for i in response.get('index')],
            value=[int(i) for i in response.get('value')],
        )


@dataclass
class NodeTreeSnapshot:
    '''
    Table containing nodes.
    '''
    #: Parent node index.
    parent_index: typing.List

    #: `Node`'s nodeType.
    node_type: typing.List

    #: `Node`'s nodeName.
    node_name: typing.List['StringIndex']

    #: `Node`'s nodeValue.
    node_value: typing.List['StringIndex']

    #: `Node`'s id, corresponds to DOM.Node.backendNodeId.
    backend_node_id: typing.List['dom.BackendNodeId']

    #: Attributes of an `Element` node. Flatten name, value pairs.
    attributes: typing.List['ArrayOfStrings']

    #: Only set for textarea elements, contains the text value.
    text_value: RareStringData

    #: Only set for input elements, contains the input's associated text value.
    input_value: RareStringData

    #: Only set for radio and checkbox input elements, indicates if the element has been checked
    input_checked: RareBooleanData

    #: Only set for option elements, indicates if the element has been selected
    option_selected: RareBooleanData

    #: The index of the document in the list of the snapshot documents.
    content_document_index: RareIntegerData

    #: Type of a pseudo element node.
    pseudo_type: RareStringData

    #: Whether this DOM node responds to mouse clicks. This includes nodes that have had click
    #: event listeners attached via JavaScript as well as anchor tags that naturally navigate when
    #: clicked.
    is_clickable: RareBooleanData

    #: The selected url for nodes with a srcset attribute.
    current_source_url: RareStringData

    #: The url of the script (if any) that generates this node.
    origin_url: RareStringData

    @classmethod
    def from_response(cls, response):
        return cls(
            parent_index=[int(i) for i in response.get('parentIndex')],
            node_type=[int(i) for i in response.get('nodeType')],
            node_name=[StringIndex.from_response(i) for i in response.get('nodeName')],
            node_value=[StringIndex.from_response(i) for i in response.get('nodeValue')],
            backend_node_id=[dom.BackendNodeId.from_response(i) for i in response.get('backendNodeId')],
            attributes=[ArrayOfStrings.from_response(i) for i in response.get('attributes')],
            text_value=RareStringData.from_response(response.get('textValue')),
            input_value=RareStringData.from_response(response.get('inputValue')),
            input_checked=RareBooleanData.from_response(response.get('inputChecked')),
            option_selected=RareBooleanData.from_response(response.get('optionSelected')),
            content_document_index=RareIntegerData.from_response(response.get('contentDocumentIndex')),
            pseudo_type=RareStringData.from_response(response.get('pseudoType')),
            is_clickable=RareBooleanData.from_response(response.get('isClickable')),
            current_source_url=RareStringData.from_response(response.get('currentSourceURL')),
            origin_url=RareStringData.from_response(response.get('originURL')),
        )


@dataclass
class LayoutTreeSnapshot:
    '''
    Table of details of an element in the DOM tree with a LayoutObject.
    '''
    #: Index of the corresponding node in the `NodeTreeSnapshot` array returned by `captureSnapshot`.
    node_index: typing.List

    #: Array of indexes specifying computed style strings, filtered according to the `computedStyles` parameter passed to `captureSnapshot`.
    styles: typing.List['ArrayOfStrings']

    #: The absolute position bounding box.
    bounds: typing.List['Rectangle']

    #: Contents of the LayoutText, if any.
    text: typing.List['StringIndex']

    #: Stacking context information.
    stacking_contexts: RareBooleanData

    @classmethod
    def from_response(cls, response):
        return cls(
            node_index=[int(i) for i in response.get('nodeIndex')],
            styles=[ArrayOfStrings.from_response(i) for i in response.get('styles')],
            bounds=[Rectangle.from_response(i) for i in response.get('bounds')],
            text=[StringIndex.from_response(i) for i in response.get('text')],
            stacking_contexts=RareBooleanData.from_response(response.get('stackingContexts')),
        )


@dataclass
class TextBoxSnapshot:
    '''
    Table of details of the post layout rendered text positions. The exact layout should not be regarded as
    stable and may change between versions.
    '''
    #: Index of the layout tree node that owns this box collection.
    layout_index: typing.List

    #: The absolute position bounding box.
    bounds: typing.List['Rectangle']

    #: The starting index in characters, for this post layout textbox substring. Characters that
    #: would be represented as a surrogate pair in UTF-16 have length 2.
    start: typing.List

    #: The number of characters in this post layout textbox substring. Characters that would be
    #: represented as a surrogate pair in UTF-16 have length 2.
    length: typing.List

    @classmethod
    def from_response(cls, response):
        return cls(
            layout_index=[int(i) for i in response.get('layoutIndex')],
            bounds=[Rectangle.from_response(i) for i in response.get('bounds')],
            start=[int(i) for i in response.get('start')],
            length=[int(i) for i in response.get('length')],
        )


@dataclass
class DocumentSnapshot:
    '''
    Document snapshot.
    '''
    #: Document URL that `Document` or `FrameOwner` node points to.
    document_url: StringIndex

    #: Base URL that `Document` or `FrameOwner` node uses for URL completion.
    base_url: StringIndex

    #: Contains the document's content language.
    content_language: StringIndex

    #: Contains the document's character set encoding.
    encoding_name: StringIndex

    #: `DocumentType` node's publicId.
    public_id: StringIndex

    #: `DocumentType` node's systemId.
    system_id: StringIndex

    #: Frame ID for frame owner elements and also for the document node.
    frame_id: StringIndex

    #: A table with dom nodes.
    nodes: NodeTreeSnapshot

    #: The nodes in the layout tree.
    layout: LayoutTreeSnapshot

    #: The post-layout inline text nodes.
    text_boxes: TextBoxSnapshot

    #: Horizontal scroll offset.
    scroll_offset_x: float

    #: Vertical scroll offset.
    scroll_offset_y: float

    @classmethod
    def from_response(cls, response):
        return cls(
            document_url=StringIndex.from_response(response.get('documentURL')),
            base_url=StringIndex.from_response(response.get('baseURL')),
            content_language=StringIndex.from_response(response.get('contentLanguage')),
            encoding_name=StringIndex.from_response(response.get('encodingName')),
            public_id=StringIndex.from_response(response.get('publicId')),
            system_id=StringIndex.from_response(response.get('systemId')),
            frame_id=StringIndex.from_response(response.get('frameId')),
            nodes=NodeTreeSnapshot.from_response(response.get('nodes')),
            layout=LayoutTreeSnapshot.from_response(response.get('layout')),
            text_boxes=TextBoxSnapshot.from_response(response.get('textBoxes')),
            scroll_offset_x=float(response.get('scrollOffsetX')),
            scroll_offset_y=float(response.get('scrollOffsetY')),
        )

