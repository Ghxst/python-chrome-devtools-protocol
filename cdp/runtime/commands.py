'''
DO NOT EDIT THIS FILE

This file is generated from the CDP definitions. If you need to make changes,
edit the generator and regenerate all of the modules.

Domain: runtime
Experimental: False
'''

from cdp.util import T_JSON_DICT
from dataclasses import dataclass
import enum
import typing

from .types import *


def await_promise(
        promise_object_id: RemoteObjectId,
        return_by_value: typing.Optional[bool] = None,
        generate_preview: typing.Optional[bool] = None,
    ) -> typing.Generator[T_JSON_DICT,T_JSON_DICT,dict]:
    '''
    Add handler to promise with given promise object id.
    
    :param promise_object_id: Identifier of the promise.
    :param return_by_value: Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: Whether preview should be generated for the result.
    :returns: a dict with the following keys:
        * result: Promise result. Will contain rejected value if promise was rejected.
        * exceptionDetails: (Optional) Exception details if stack strace is available.
    '''
    params: T_JSON_DICT = {
        'promiseObjectId': promise_object_id.to_json(),
    }
    if return_by_value is not None:
        params['returnByValue'] = return_by_value
    if generate_preview is not None:
        params['generatePreview'] = generate_preview
    cmd_dict: T_JSON_DICT = {
        'method': 'Runtime.awaitPromise',
        'params': params,
    }
    json = yield cmd_dict
    result: T_JSON_DICT = {
        'result': RemoteObject.from_json(json['result']),
    }
    if 'exceptionDetails' in json:
        result['exceptionDetails'] = ExceptionDetails.from_json(json['exceptionDetails'])
    return result


def call_function_on(
        function_declaration: str,
        object_id: typing.Optional[RemoteObjectId] = None,
        arguments: typing.Optional[typing.List['CallArgument']] = None,
        silent: typing.Optional[bool] = None,
        return_by_value: typing.Optional[bool] = None,
        generate_preview: typing.Optional[bool] = None,
        user_gesture: typing.Optional[bool] = None,
        await_promise: typing.Optional[bool] = None,
        execution_context_id: typing.Optional[ExecutionContextId] = None,
        object_group: typing.Optional[str] = None,
    ) -> typing.Generator[T_JSON_DICT,T_JSON_DICT,dict]:
    '''
    Calls function with given declaration on the given object. Object group of the result is
    inherited from the target object.
    
    :param function_declaration: Declaration of the function to call.
    :param object_id: Identifier of the object to call function on. Either objectId or executionContextId should
    be specified.
    :param arguments: Call arguments. All call arguments must belong to the same JavaScript world as the target
    object.
    :param silent: In silent mode exceptions thrown during evaluation are not reported and do not pause
    execution. Overrides `setPauseOnException` state.
    :param return_by_value: Whether the result is expected to be a JSON object which should be sent by value.
    :param generate_preview: Whether preview should be generated for the result.
    :param user_gesture: Whether execution should be treated as initiated by user in the UI.
    :param await_promise: Whether execution should `await` for resulting value and return once awaited promise is
    resolved.
    :param execution_context_id: Specifies execution context which global object will be used to call function on. Either
    executionContextId or objectId should be specified.
    :param object_group: Symbolic group name that can be used to release multiple objects. If objectGroup is not
    specified and objectId is, objectGroup will be inherited from object.
    :returns: a dict with the following keys:
        * result: Call result.
        * exceptionDetails: (Optional) Exception details.
    '''
    params: T_JSON_DICT = {
        'functionDeclaration': function_declaration,
    }
    if object_id is not None:
        params['objectId'] = object_id.to_json()
    if arguments is not None:
        params['arguments'] = [i.to_json() for i in arguments]
    if silent is not None:
        params['silent'] = silent
    if return_by_value is not None:
        params['returnByValue'] = return_by_value
    if generate_preview is not None:
        params['generatePreview'] = generate_preview
    if user_gesture is not None:
        params['userGesture'] = user_gesture
    if await_promise is not None:
        params['awaitPromise'] = await_promise
    if execution_context_id is not None:
        params['executionContextId'] = execution_context_id.to_json()
    if object_group is not None:
        params['objectGroup'] = object_group
    cmd_dict: T_JSON_DICT = {
        'method': 'Runtime.callFunctionOn',
        'params': params,
    }
    json = yield cmd_dict
    result: T_JSON_DICT = {
        'result': RemoteObject.from_json(json['result']),
    }
    if 'exceptionDetails' in json:
        result['exceptionDetails'] = ExceptionDetails.from_json(json['exceptionDetails'])
    return result


def compile_script(
        expression: str,
        source_url: str,
        persist_script: bool,
        execution_context_id: typing.Optional[ExecutionContextId] = None,
    ) -> typing.Generator[T_JSON_DICT,T_JSON_DICT,dict]:
    '''
    Compiles expression.
    
    :param expression: Expression to compile.
    :param source_url: Source url to be set for the script.
    :param persist_script: Specifies whether the compiled script should be persisted.
    :param execution_context_id: Specifies in which execution context to perform script run. If the parameter is omitted the
    evaluation will be performed in the context of the inspected page.
    :returns: a dict with the following keys:
        * scriptId: (Optional) Id of the script.
        * exceptionDetails: (Optional) Exception details.
    '''
    params: T_JSON_DICT = {
        'expression': expression,
        'sourceURL': source_url,
        'persistScript': persist_script,
    }
    if execution_context_id is not None:
        params['executionContextId'] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        'method': 'Runtime.compileScript',
        'params': params,
    }
    json = yield cmd_dict
    result: T_JSON_DICT = {
    }
    if 'scriptId' in json:
        result['scriptId'] = ScriptId.from_json(json['scriptId'])
    if 'exceptionDetails' in json:
        result['exceptionDetails'] = ExceptionDetails.from_json(json['exceptionDetails'])
    return result


def disable() -> typing.Generator[T_JSON_DICT,T_JSON_DICT,None]:
    '''
    Disables reporting of execution contexts creation.
    '''
    cmd_dict: T_JSON_DICT = {
        'method': 'Runtime.disable',
    }
    json = yield cmd_dict


def discard_console_entries() -> typing.Generator[T_JSON_DICT,T_JSON_DICT,None]:
    '''
    Discards collected exceptions and console API calls.
    '''
    cmd_dict: T_JSON_DICT = {
        'method': 'Runtime.discardConsoleEntries',
    }
    json = yield cmd_dict


def enable() -> typing.Generator[T_JSON_DICT,T_JSON_DICT,None]:
    '''
    Enables reporting of execution contexts creation by means of `executionContextCreated` event.
    When the reporting gets enabled the event will be sent immediately for each existing execution
    context.
    '''
    cmd_dict: T_JSON_DICT = {
        'method': 'Runtime.enable',
    }
    json = yield cmd_dict


def evaluate(
        expression: str,
        object_group: typing.Optional[str] = None,
        include_command_line_api: typing.Optional[bool] = None,
        silent: typing.Optional[bool] = None,
        context_id: typing.Optional[ExecutionContextId] = None,
        return_by_value: typing.Optional[bool] = None,
        generate_preview: typing.Optional[bool] = None,
        user_gesture: typing.Optional[bool] = None,
        await_promise: typing.Optional[bool] = None,
        throw_on_side_effect: typing.Optional[bool] = None,
        timeout: typing.Optional[TimeDelta] = None,
    ) -> typing.Generator[T_JSON_DICT,T_JSON_DICT,dict]:
    '''
    Evaluates expression on global object.
    
    :param expression: Expression to evaluate.
    :param object_group: Symbolic group name that can be used to release multiple objects.
    :param include_command_line_api: Determines whether Command Line API should be available during the evaluation.
    :param silent: In silent mode exceptions thrown during evaluation are not reported and do not pause
    execution. Overrides `setPauseOnException` state.
    :param context_id: Specifies in which execution context to perform evaluation. If the parameter is omitted the
    evaluation will be performed in the context of the inspected page.
    :param return_by_value: Whether the result is expected to be a JSON object that should be sent by value.
    :param generate_preview: Whether preview should be generated for the result.
    :param user_gesture: Whether execution should be treated as initiated by user in the UI.
    :param await_promise: Whether execution should `await` for resulting value and return once awaited promise is
    resolved.
    :param throw_on_side_effect: Whether to throw an exception if side effect cannot be ruled out during evaluation.
    :param timeout: Terminate execution after timing out (number of milliseconds).
    :returns: a dict with the following keys:
        * result: Evaluation result.
        * exceptionDetails: (Optional) Exception details.
    '''
    params: T_JSON_DICT = {
        'expression': expression,
    }
    if object_group is not None:
        params['objectGroup'] = object_group
    if include_command_line_api is not None:
        params['includeCommandLineAPI'] = include_command_line_api
    if silent is not None:
        params['silent'] = silent
    if context_id is not None:
        params['contextId'] = context_id.to_json()
    if return_by_value is not None:
        params['returnByValue'] = return_by_value
    if generate_preview is not None:
        params['generatePreview'] = generate_preview
    if user_gesture is not None:
        params['userGesture'] = user_gesture
    if await_promise is not None:
        params['awaitPromise'] = await_promise
    if throw_on_side_effect is not None:
        params['throwOnSideEffect'] = throw_on_side_effect
    if timeout is not None:
        params['timeout'] = timeout.to_json()
    cmd_dict: T_JSON_DICT = {
        'method': 'Runtime.evaluate',
        'params': params,
    }
    json = yield cmd_dict
    result: T_JSON_DICT = {
        'result': RemoteObject.from_json(json['result']),
    }
    if 'exceptionDetails' in json:
        result['exceptionDetails'] = ExceptionDetails.from_json(json['exceptionDetails'])
    return result


def get_isolate_id() -> typing.Generator[T_JSON_DICT,T_JSON_DICT,str]:
    '''
    Returns the isolate id.
    :returns: The isolate id.
    '''
    cmd_dict: T_JSON_DICT = {
        'method': 'Runtime.getIsolateId',
    }
    json = yield cmd_dict
    return str(json['id'])


def get_heap_usage() -> typing.Generator[T_JSON_DICT,T_JSON_DICT,dict]:
    '''
    Returns the JavaScript heap usage.
    It is the total usage of the corresponding isolate not scoped to a particular Runtime.
    :returns: a dict with the following keys:
        * usedSize: Used heap size in bytes.
        * totalSize: Allocated heap size in bytes.
    '''
    cmd_dict: T_JSON_DICT = {
        'method': 'Runtime.getHeapUsage',
    }
    json = yield cmd_dict
    result: T_JSON_DICT = {
        'usedSize': float(json['usedSize']),
        'totalSize': float(json['totalSize']),
    }
    return result


def get_properties(
        object_id: RemoteObjectId,
        own_properties: typing.Optional[bool] = None,
        accessor_properties_only: typing.Optional[bool] = None,
        generate_preview: typing.Optional[bool] = None,
    ) -> typing.Generator[T_JSON_DICT,T_JSON_DICT,dict]:
    '''
    Returns properties of a given object. Object group of the result is inherited from the target
    object.
    
    :param object_id: Identifier of the object to return properties for.
    :param own_properties: If true, returns properties belonging only to the element itself, not to its prototype
    chain.
    :param accessor_properties_only: If true, returns accessor properties (with getter/setter) only; internal properties are not
    returned either.
    :param generate_preview: Whether preview should be generated for the results.
    :returns: a dict with the following keys:
        * result: Object properties.
        * internalProperties: (Optional) Internal object properties (only of the element itself).
        * privateProperties: (Optional) Object private properties.
        * exceptionDetails: (Optional) Exception details.
    '''
    params: T_JSON_DICT = {
        'objectId': object_id.to_json(),
    }
    if own_properties is not None:
        params['ownProperties'] = own_properties
    if accessor_properties_only is not None:
        params['accessorPropertiesOnly'] = accessor_properties_only
    if generate_preview is not None:
        params['generatePreview'] = generate_preview
    cmd_dict: T_JSON_DICT = {
        'method': 'Runtime.getProperties',
        'params': params,
    }
    json = yield cmd_dict
    result: T_JSON_DICT = {
        'result': [PropertyDescriptor.from_json(i) for i in json['result']],
    }
    if 'internalProperties' in json:
        result['internalProperties'] = [InternalPropertyDescriptor.from_json(i) for i in json['internalProperties']]
    if 'privateProperties' in json:
        result['privateProperties'] = [PrivatePropertyDescriptor.from_json(i) for i in json['privateProperties']]
    if 'exceptionDetails' in json:
        result['exceptionDetails'] = ExceptionDetails.from_json(json['exceptionDetails'])
    return result


def global_lexical_scope_names(
        execution_context_id: typing.Optional[ExecutionContextId] = None,
    ) -> typing.Generator[T_JSON_DICT,T_JSON_DICT,typing.List['str']]:
    '''
    Returns all let, const and class variables from global scope.
    
    :param execution_context_id: Specifies in which execution context to lookup global scope variables.
    :returns: 
    '''
    params: T_JSON_DICT = {
    }
    if execution_context_id is not None:
        params['executionContextId'] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        'method': 'Runtime.globalLexicalScopeNames',
        'params': params,
    }
    json = yield cmd_dict
    return [str(i) for i in json['names']]


def query_objects(
        prototype_object_id: RemoteObjectId,
        object_group: typing.Optional[str] = None,
    ) -> typing.Generator[T_JSON_DICT,T_JSON_DICT,RemoteObject]:
    '''
    
    
    :param prototype_object_id: Identifier of the prototype to return objects for.
    :param object_group: Symbolic group name that can be used to release the results.
    :returns: Array with objects.
    '''
    params: T_JSON_DICT = {
        'prototypeObjectId': prototype_object_id.to_json(),
    }
    if object_group is not None:
        params['objectGroup'] = object_group
    cmd_dict: T_JSON_DICT = {
        'method': 'Runtime.queryObjects',
        'params': params,
    }
    json = yield cmd_dict
    return RemoteObject.from_json(json['objects'])


def release_object(
        object_id: RemoteObjectId,
    ) -> typing.Generator[T_JSON_DICT,T_JSON_DICT,None]:
    '''
    Releases remote object with given id.
    
    :param object_id: Identifier of the object to release.
    '''
    params: T_JSON_DICT = {
        'objectId': object_id.to_json(),
    }
    cmd_dict: T_JSON_DICT = {
        'method': 'Runtime.releaseObject',
        'params': params,
    }
    json = yield cmd_dict


def release_object_group(
        object_group: str,
    ) -> typing.Generator[T_JSON_DICT,T_JSON_DICT,None]:
    '''
    Releases all remote objects that belong to a given group.
    
    :param object_group: Symbolic object group name.
    '''
    params: T_JSON_DICT = {
        'objectGroup': object_group,
    }
    cmd_dict: T_JSON_DICT = {
        'method': 'Runtime.releaseObjectGroup',
        'params': params,
    }
    json = yield cmd_dict


def run_if_waiting_for_debugger() -> typing.Generator[T_JSON_DICT,T_JSON_DICT,None]:
    '''
    Tells inspected instance to run if it was waiting for debugger to attach.
    '''
    cmd_dict: T_JSON_DICT = {
        'method': 'Runtime.runIfWaitingForDebugger',
    }
    json = yield cmd_dict


def run_script(
        script_id: ScriptId,
        execution_context_id: typing.Optional[ExecutionContextId] = None,
        object_group: typing.Optional[str] = None,
        silent: typing.Optional[bool] = None,
        include_command_line_api: typing.Optional[bool] = None,
        return_by_value: typing.Optional[bool] = None,
        generate_preview: typing.Optional[bool] = None,
        await_promise: typing.Optional[bool] = None,
    ) -> typing.Generator[T_JSON_DICT,T_JSON_DICT,dict]:
    '''
    Runs script with given id in a given context.
    
    :param script_id: Id of the script to run.
    :param execution_context_id: Specifies in which execution context to perform script run. If the parameter is omitted the
    evaluation will be performed in the context of the inspected page.
    :param object_group: Symbolic group name that can be used to release multiple objects.
    :param silent: In silent mode exceptions thrown during evaluation are not reported and do not pause
    execution. Overrides `setPauseOnException` state.
    :param include_command_line_api: Determines whether Command Line API should be available during the evaluation.
    :param return_by_value: Whether the result is expected to be a JSON object which should be sent by value.
    :param generate_preview: Whether preview should be generated for the result.
    :param await_promise: Whether execution should `await` for resulting value and return once awaited promise is
    resolved.
    :returns: a dict with the following keys:
        * result: Run result.
        * exceptionDetails: (Optional) Exception details.
    '''
    params: T_JSON_DICT = {
        'scriptId': script_id.to_json(),
    }
    if execution_context_id is not None:
        params['executionContextId'] = execution_context_id.to_json()
    if object_group is not None:
        params['objectGroup'] = object_group
    if silent is not None:
        params['silent'] = silent
    if include_command_line_api is not None:
        params['includeCommandLineAPI'] = include_command_line_api
    if return_by_value is not None:
        params['returnByValue'] = return_by_value
    if generate_preview is not None:
        params['generatePreview'] = generate_preview
    if await_promise is not None:
        params['awaitPromise'] = await_promise
    cmd_dict: T_JSON_DICT = {
        'method': 'Runtime.runScript',
        'params': params,
    }
    json = yield cmd_dict
    result: T_JSON_DICT = {
        'result': RemoteObject.from_json(json['result']),
    }
    if 'exceptionDetails' in json:
        result['exceptionDetails'] = ExceptionDetails.from_json(json['exceptionDetails'])
    return result


def set_async_call_stack_depth(
        max_depth: int,
    ) -> typing.Generator[T_JSON_DICT,T_JSON_DICT,None]:
    '''
    Enables or disables async call stacks tracking.
    
    :param max_depth: Maximum depth of async call stacks. Setting to `0` will effectively disable collecting async
    call stacks (default).
    '''
    params: T_JSON_DICT = {
        'maxDepth': max_depth,
    }
    cmd_dict: T_JSON_DICT = {
        'method': 'Runtime.setAsyncCallStackDepth',
        'params': params,
    }
    json = yield cmd_dict


def set_custom_object_formatter_enabled(
        enabled: bool,
    ) -> typing.Generator[T_JSON_DICT,T_JSON_DICT,None]:
    '''
    
    
    :param enabled: 
    '''
    params: T_JSON_DICT = {
        'enabled': enabled,
    }
    cmd_dict: T_JSON_DICT = {
        'method': 'Runtime.setCustomObjectFormatterEnabled',
        'params': params,
    }
    json = yield cmd_dict


def set_max_call_stack_size_to_capture(
        size: int,
    ) -> typing.Generator[T_JSON_DICT,T_JSON_DICT,None]:
    '''
    
    
    :param size: 
    '''
    params: T_JSON_DICT = {
        'size': size,
    }
    cmd_dict: T_JSON_DICT = {
        'method': 'Runtime.setMaxCallStackSizeToCapture',
        'params': params,
    }
    json = yield cmd_dict


def terminate_execution() -> typing.Generator[T_JSON_DICT,T_JSON_DICT,None]:
    '''
    Terminate current or next JavaScript execution.
    Will cancel the termination when the outer-most script execution ends.
    '''
    cmd_dict: T_JSON_DICT = {
        'method': 'Runtime.terminateExecution',
    }
    json = yield cmd_dict


def add_binding(
        name: str,
        execution_context_id: typing.Optional[ExecutionContextId] = None,
    ) -> typing.Generator[T_JSON_DICT,T_JSON_DICT,None]:
    '''
    If executionContextId is empty, adds binding with the given name on the
    global objects of all inspected contexts, including those created later,
    bindings survive reloads.
    If executionContextId is specified, adds binding only on global object of
    given execution context.
    Binding function takes exactly one argument, this argument should be string,
    in case of any other input, function throws an exception.
    Each binding function call produces Runtime.bindingCalled notification.
    
    :param name: 
    :param execution_context_id: 
    '''
    params: T_JSON_DICT = {
        'name': name,
    }
    if execution_context_id is not None:
        params['executionContextId'] = execution_context_id.to_json()
    cmd_dict: T_JSON_DICT = {
        'method': 'Runtime.addBinding',
        'params': params,
    }
    json = yield cmd_dict


def remove_binding(
        name: str,
    ) -> typing.Generator[T_JSON_DICT,T_JSON_DICT,None]:
    '''
    This method does not remove binding function from global object but
    unsubscribes current runtime agent from Runtime.bindingCalled notifications.
    
    :param name: 
    '''
    params: T_JSON_DICT = {
        'name': name,
    }
    cmd_dict: T_JSON_DICT = {
        'method': 'Runtime.removeBinding',
        'params': params,
    }
    json = yield cmd_dict


