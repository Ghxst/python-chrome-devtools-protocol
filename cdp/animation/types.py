'''
DO NOT EDIT THIS FILE

This file is generated from the CDP definitions. If you need to make changes,
edit the generator and regenerate all of the modules.

Domain: animation
Experimental: True
'''

from cdp.util import T_JSON_DICT
from dataclasses import dataclass
import enum
import typing

from ..dom import types as dom


@dataclass
class KeyframesRule:
    '''
    Keyframes Rule
    '''
    #: List of animation keyframes.
    keyframes: typing.List['KeyframeStyle']

    #: CSS keyframed animation's name.
    name: typing.Optional[str] = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {
            'keyframes': [i.to_json() for i in self.keyframes],
        }
        if self.name is not None:
            json['name'] = self.name
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> 'KeyframesRule':
        name = json['name'] if 'name' in json else None
        return cls(
            name=name,
            keyframes=[KeyframeStyle.from_json(i) for i in json['keyframes']],
        )

@dataclass
class KeyframeStyle:
    '''
    Keyframe Style
    '''
    #: Keyframe's time offset.
    offset: str

    #: `AnimationEffect`'s timing function.
    easing: str

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {
            'offset': self.offset,
            'easing': self.easing,
        }
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> 'KeyframeStyle':
        return cls(
            offset=json['offset'],
            easing=json['easing'],
        )

@dataclass
class AnimationEffect:
    '''
    AnimationEffect instance
    '''
    #: `AnimationEffect`'s delay.
    delay: float

    #: `AnimationEffect`'s end delay.
    end_delay: float

    #: `AnimationEffect`'s iteration start.
    iteration_start: float

    #: `AnimationEffect`'s iterations.
    iterations: float

    #: `AnimationEffect`'s iteration duration.
    duration: float

    #: `AnimationEffect`'s playback direction.
    direction: str

    #: `AnimationEffect`'s fill mode.
    fill: str

    #: `AnimationEffect`'s timing function.
    easing: str

    #: `AnimationEffect`'s target node.
    backend_node_id: typing.Optional[dom.BackendNodeId] = None

    #: `AnimationEffect`'s keyframes.
    keyframes_rule: typing.Optional[KeyframesRule] = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {
            'delay': self.delay,
            'endDelay': self.end_delay,
            'iterationStart': self.iteration_start,
            'iterations': self.iterations,
            'duration': self.duration,
            'direction': self.direction,
            'fill': self.fill,
            'easing': self.easing,
        }
        if self.backend_node_id is not None:
            json['backendNodeId'] = self.backend_node_id.to_json()
        if self.keyframes_rule is not None:
            json['keyframesRule'] = self.keyframes_rule.to_json()
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> 'AnimationEffect':
        backend_node_id = dom.BackendNodeId.from_json(json['backendNodeId']) if 'backendNodeId' in json else None
        keyframes_rule = KeyframesRule.from_json(json['keyframesRule']) if 'keyframesRule' in json else None
        return cls(
            delay=json['delay'],
            end_delay=json['endDelay'],
            iteration_start=json['iterationStart'],
            iterations=json['iterations'],
            duration=json['duration'],
            direction=json['direction'],
            fill=json['fill'],
            backend_node_id=backend_node_id,
            keyframes_rule=keyframes_rule,
            easing=json['easing'],
        )

@dataclass
class Animation:
    '''
    Animation instance.
    '''
    #: `Animation`'s id.
    id: str

    #: `Animation`'s name.
    name: str

    #: `Animation`'s internal paused state.
    paused_state: bool

    #: `Animation`'s play state.
    play_state: str

    #: `Animation`'s playback rate.
    playback_rate: float

    #: `Animation`'s start time.
    start_time: float

    #: `Animation`'s current time.
    current_time: float

    #: Animation type of `Animation`.
    type: str

    #: `Animation`'s source animation node.
    source: typing.Optional[AnimationEffect] = None

    #: A unique ID for `Animation` representing the sources that triggered this CSS
    #: animation/transition.
    css_id: typing.Optional[str] = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {
            'id': self.id,
            'name': self.name,
            'pausedState': self.paused_state,
            'playState': self.play_state,
            'playbackRate': self.playback_rate,
            'startTime': self.start_time,
            'currentTime': self.current_time,
            'type': self.type,
        }
        if self.source is not None:
            json['source'] = self.source.to_json()
        if self.css_id is not None:
            json['cssId'] = self.css_id
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> 'Animation':
        source = AnimationEffect.from_json(json['source']) if 'source' in json else None
        css_id = json['cssId'] if 'cssId' in json else None
        return cls(
            id=json['id'],
            name=json['name'],
            paused_state=json['pausedState'],
            play_state=json['playState'],
            playback_rate=json['playbackRate'],
            start_time=json['startTime'],
            current_time=json['currentTime'],
            type=json['type'],
            source=source,
            css_id=css_id,
        )

