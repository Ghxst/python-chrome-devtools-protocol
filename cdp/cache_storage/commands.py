'''
DO NOT EDIT THIS FILE

This file is generated from the CDP definitions. If you need to make changes,
edit the generator and regenerate all of the modules.

Domain: cache_storage
Experimental: True
'''

from cdp.util import T_JSON_DICT
from dataclasses import dataclass
import enum
import typing

from .types import *


def delete_cache(
        cache_id: CacheId,
    ) -> typing.Generator[T_JSON_DICT,T_JSON_DICT,None]:
    '''
    Deletes a cache.
    
    :param cache_id: Id of cache for deletion.
    '''
    params: T_JSON_DICT = {
        'cacheId': cache_id.to_json(),
    }
    cmd_dict: T_JSON_DICT = {
        'method': 'CacheStorage.deleteCache',
        'params': params,
    }
    json = yield cmd_dict


def delete_entry(
        cache_id: CacheId,
        request: str,
    ) -> typing.Generator[T_JSON_DICT,T_JSON_DICT,None]:
    '''
    Deletes a cache entry.
    
    :param cache_id: Id of cache where the entry will be deleted.
    :param request: URL spec of the request.
    '''
    params: T_JSON_DICT = {
        'cacheId': cache_id.to_json(),
        'request': request,
    }
    cmd_dict: T_JSON_DICT = {
        'method': 'CacheStorage.deleteEntry',
        'params': params,
    }
    json = yield cmd_dict


def request_cache_names(
        security_origin: str,
    ) -> typing.Generator[T_JSON_DICT,T_JSON_DICT,typing.List['Cache']]:
    '''
    Requests cache names.
    
    :param security_origin: Security origin.
    :returns: Caches for the security origin.
    '''
    params: T_JSON_DICT = {
        'securityOrigin': security_origin,
    }
    cmd_dict: T_JSON_DICT = {
        'method': 'CacheStorage.requestCacheNames',
        'params': params,
    }
    json = yield cmd_dict
    return [Cache.from_json(i) for i in json['caches']]


def request_cached_response(
        cache_id: CacheId,
        request_url: str,
        request_headers: typing.List['Header'],
    ) -> typing.Generator[T_JSON_DICT,T_JSON_DICT,CachedResponse]:
    '''
    Fetches cache entry.
    
    :param cache_id: Id of cache that contains the entry.
    :param request_url: URL spec of the request.
    :param request_headers: headers of the request.
    :returns: Response read from the cache.
    '''
    params: T_JSON_DICT = {
        'cacheId': cache_id.to_json(),
        'requestURL': request_url,
        'requestHeaders': [i.to_json() for i in request_headers],
    }
    cmd_dict: T_JSON_DICT = {
        'method': 'CacheStorage.requestCachedResponse',
        'params': params,
    }
    json = yield cmd_dict
    return CachedResponse.from_json(json['response'])


def request_entries(
        cache_id: CacheId,
        skip_count: int,
        page_size: int,
        path_filter: typing.Optional[str] = None,
    ) -> typing.Generator[T_JSON_DICT,T_JSON_DICT,dict]:
    '''
    Requests data from cache.
    
    :param cache_id: ID of cache to get entries from.
    :param skip_count: Number of records to skip.
    :param page_size: Number of records to fetch.
    :param path_filter: If present, only return the entries containing this substring in the path
    :returns: a dict with the following keys:
        * cacheDataEntries: Array of object store data entries.
        * returnCount: Count of returned entries from this storage. If pathFilter is empty, it
    is the count of all entries from this storage.
    '''
    params: T_JSON_DICT = {
        'cacheId': cache_id.to_json(),
        'skipCount': skip_count,
        'pageSize': page_size,
    }
    if path_filter is not None:
        params['pathFilter'] = path_filter
    cmd_dict: T_JSON_DICT = {
        'method': 'CacheStorage.requestEntries',
        'params': params,
    }
    json = yield cmd_dict
    result: T_JSON_DICT = {
        'cacheDataEntries': [DataEntry.from_json(i) for i in json['cacheDataEntries']],
        'returnCount': float(json['returnCount']),
    }
    return result


