'''
DO NOT EDIT THIS FILE

This file is generated from the CDP definitions. If you need to make changes,
edit the generator and regenerate all of the modules.

Domain: network
Experimental: False
'''

from dataclasses import dataclass, field
import typing

from ..runtime import types as runtime
from ..security import types as security



class ResourceType:
    '''
    Resource type as it was perceived by the rendering engine.
    '''
    DOCUMENT = "Document"
    STYLESHEET = "Stylesheet"
    IMAGE = "Image"
    MEDIA = "Media"
    FONT = "Font"
    SCRIPT = "Script"
    TEXT_TRACK = "TextTrack"
    XHR = "XHR"
    FETCH = "Fetch"
    EVENT_SOURCE = "EventSource"
    WEB_SOCKET = "WebSocket"
    MANIFEST = "Manifest"
    SIGNED_EXCHANGE = "SignedExchange"
    PING = "Ping"
    CSP_VIOLATION_REPORT = "CSPViolationReport"
    OTHER = "Other"

class LoaderId(str):
    '''
    Unique loader identifier.
    '''
    @classmethod
    def from_response(cls, response):
        return cls(response)

    def __repr__(self):
        return 'LoaderId({})'.format(str.__repr__(self))


class RequestId(str):
    '''
    Unique request identifier.
    '''
    @classmethod
    def from_response(cls, response):
        return cls(response)

    def __repr__(self):
        return 'RequestId({})'.format(str.__repr__(self))


class InterceptionId(str):
    '''
    Unique intercepted request identifier.
    '''
    @classmethod
    def from_response(cls, response):
        return cls(response)

    def __repr__(self):
        return 'InterceptionId({})'.format(str.__repr__(self))



class ErrorReason:
    '''
    Network level fetch failure reason.
    '''
    FAILED = "Failed"
    ABORTED = "Aborted"
    TIMED_OUT = "TimedOut"
    ACCESS_DENIED = "AccessDenied"
    CONNECTION_CLOSED = "ConnectionClosed"
    CONNECTION_RESET = "ConnectionReset"
    CONNECTION_REFUSED = "ConnectionRefused"
    CONNECTION_ABORTED = "ConnectionAborted"
    CONNECTION_FAILED = "ConnectionFailed"
    NAME_NOT_RESOLVED = "NameNotResolved"
    INTERNET_DISCONNECTED = "InternetDisconnected"
    ADDRESS_UNREACHABLE = "AddressUnreachable"
    BLOCKED_BY_CLIENT = "BlockedByClient"
    BLOCKED_BY_RESPONSE = "BlockedByResponse"

class TimeSinceEpoch(float):
    '''
    UTC time in seconds, counted from January 1, 1970.
    '''
    @classmethod
    def from_response(cls, response):
        return cls(response)

    def __repr__(self):
        return 'TimeSinceEpoch({})'.format(float.__repr__(self))


class MonotonicTime(float):
    '''
    Monotonically increasing time in seconds since an arbitrary point in the past.
    '''
    @classmethod
    def from_response(cls, response):
        return cls(response)

    def __repr__(self):
        return 'MonotonicTime({})'.format(float.__repr__(self))



class ConnectionType:
    '''
    The underlying connection technology that the browser is supposedly using.
    '''
    NONE = "none"
    CELLULAR2G = "cellular2g"
    CELLULAR3G = "cellular3g"
    CELLULAR4G = "cellular4g"
    BLUETOOTH = "bluetooth"
    ETHERNET = "ethernet"
    WIFI = "wifi"
    WIMAX = "wimax"
    OTHER = "other"


class CookieSameSite:
    '''
    Represents the cookie's 'SameSite' status:
    https://tools.ietf.org/html/draft-west-first-party-cookies
    '''
    STRICT = "Strict"
    LAX = "Lax"
    EXTENDED = "Extended"
    NONE = "None"


class ResourcePriority:
    '''
    Loading priority of a resource request.
    '''
    VERY_LOW = "VeryLow"
    LOW = "Low"
    MEDIUM = "Medium"
    HIGH = "High"
    VERY_HIGH = "VeryHigh"


class CertificateTransparencyCompliance:
    '''
    Whether the request complied with Certificate Transparency policy.
    '''
    UNKNOWN = "unknown"
    NOT_COMPLIANT = "not-compliant"
    COMPLIANT = "compliant"


class BlockedReason:
    '''
    The reason why request was blocked.
    '''
    OTHER = "other"
    CSP = "csp"
    MIXED_CONTENT = "mixed-content"
    ORIGIN = "origin"
    INSPECTOR = "inspector"
    SUBRESOURCE_FILTER = "subresource-filter"
    CONTENT_TYPE = "content-type"
    COLLAPSED_BY_CLIENT = "collapsed-by-client"


class InterceptionStage:
    '''
    Stages of the interception to begin intercepting. Request will intercept before the request is
    sent. Response will intercept after the response is received.
    '''
    REQUEST = "Request"
    HEADERS_RECEIVED = "HeadersReceived"


class SignedExchangeErrorField:
    '''
    Field type for a signed exchange related error.
    '''
    SIGNATURE_SIG = "signatureSig"
    SIGNATURE_INTEGRITY = "signatureIntegrity"
    SIGNATURE_CERT_URL = "signatureCertUrl"
    SIGNATURE_CERT_SHA256 = "signatureCertSha256"
    SIGNATURE_VALIDITY_URL = "signatureValidityUrl"
    SIGNATURE_TIMESTAMPS = "signatureTimestamps"


@dataclass
class Headers:
    '''
    Request / response headers as keys / values of JSON object.
    '''
    @classmethod
    def from_response(cls, response):
        return cls(
        )


@dataclass
class ResourceTiming:
    '''
    Timing information for the request.
    '''
    #: Timing's requestTime is a baseline in seconds, while the other numbers are ticks in
    #: milliseconds relatively to this requestTime.
    request_time: float

    #: Started resolving proxy.
    proxy_start: float

    #: Finished resolving proxy.
    proxy_end: float

    #: Started DNS address resolve.
    dns_start: float

    #: Finished DNS address resolve.
    dns_end: float

    #: Started connecting to the remote host.
    connect_start: float

    #: Connected to the remote host.
    connect_end: float

    #: Started SSL handshake.
    ssl_start: float

    #: Finished SSL handshake.
    ssl_end: float

    #: Started running ServiceWorker.
    worker_start: float

    #: Finished Starting ServiceWorker.
    worker_ready: float

    #: Started sending request.
    send_start: float

    #: Finished sending request.
    send_end: float

    #: Time the server started pushing request.
    push_start: float

    #: Time the server finished pushing request.
    push_end: float

    #: Finished receiving response headers.
    receive_headers_end: float

    @classmethod
    def from_response(cls, response):
        return cls(
            request_time=float(response.get('requestTime')),
            proxy_start=float(response.get('proxyStart')),
            proxy_end=float(response.get('proxyEnd')),
            dns_start=float(response.get('dnsStart')),
            dns_end=float(response.get('dnsEnd')),
            connect_start=float(response.get('connectStart')),
            connect_end=float(response.get('connectEnd')),
            ssl_start=float(response.get('sslStart')),
            ssl_end=float(response.get('sslEnd')),
            worker_start=float(response.get('workerStart')),
            worker_ready=float(response.get('workerReady')),
            send_start=float(response.get('sendStart')),
            send_end=float(response.get('sendEnd')),
            push_start=float(response.get('pushStart')),
            push_end=float(response.get('pushEnd')),
            receive_headers_end=float(response.get('receiveHeadersEnd')),
        )


@dataclass
class Request:
    '''
    HTTP request data.
    '''
    #: Request URL (without fragment).
    url: str

    #: Fragment of the requested URL starting with hash, if present.
    url_fragment: str

    #: HTTP request method.
    method: str

    #: HTTP request headers.
    headers: Headers

    #: HTTP POST request data.
    post_data: str

    #: True when the request has POST data. Note that postData might still be omitted when this flag is true when the data is too long.
    has_post_data: bool

    #: The mixed content type of the request.
    mixed_content_type: security.MixedContentType

    #: Priority of the resource request at the time request is sent.
    initial_priority: ResourcePriority

    #: The referrer policy of the request, as defined in https://www.w3.org/TR/referrer-policy/
    referrer_policy: str

    #: Whether is loaded via link preload.
    is_link_preload: bool

    @classmethod
    def from_response(cls, response):
        return cls(
            url=str(response.get('url')),
            url_fragment=str(response.get('urlFragment')),
            method=str(response.get('method')),
            headers=Headers.from_response(response.get('headers')),
            post_data=str(response.get('postData')),
            has_post_data=bool(response.get('hasPostData')),
            mixed_content_type=security.MixedContentType.from_response(response.get('mixedContentType')),
            initial_priority=ResourcePriority.from_response(response.get('initialPriority')),
            referrer_policy=str(response.get('referrerPolicy')),
            is_link_preload=bool(response.get('isLinkPreload')),
        )


@dataclass
class SignedCertificateTimestamp:
    '''
    Details of a signed certificate timestamp (SCT).
    '''
    #: Validation status.
    status: str

    #: Origin.
    origin: str

    #: Log name / description.
    log_description: str

    #: Log ID.
    log_id: str

    #: Issuance date.
    timestamp: TimeSinceEpoch

    #: Hash algorithm.
    hash_algorithm: str

    #: Signature algorithm.
    signature_algorithm: str

    #: Signature data.
    signature_data: str

    @classmethod
    def from_response(cls, response):
        return cls(
            status=str(response.get('status')),
            origin=str(response.get('origin')),
            log_description=str(response.get('logDescription')),
            log_id=str(response.get('logId')),
            timestamp=TimeSinceEpoch.from_response(response.get('timestamp')),
            hash_algorithm=str(response.get('hashAlgorithm')),
            signature_algorithm=str(response.get('signatureAlgorithm')),
            signature_data=str(response.get('signatureData')),
        )


@dataclass
class SecurityDetails:
    '''
    Security details about a request.
    '''
    #: Protocol name (e.g. "TLS 1.2" or "QUIC").
    protocol: str

    #: Key Exchange used by the connection, or the empty string if not applicable.
    key_exchange: str

    #: (EC)DH group used by the connection, if applicable.
    key_exchange_group: str

    #: Cipher name.
    cipher: str

    #: TLS MAC. Note that AEAD ciphers do not have separate MACs.
    mac: str

    #: Certificate ID value.
    certificate_id: security.CertificateId

    #: Certificate subject name.
    subject_name: str

    #: Subject Alternative Name (SAN) DNS names and IP addresses.
    san_list: typing.List

    #: Name of the issuing CA.
    issuer: str

    #: Certificate valid from date.
    valid_from: TimeSinceEpoch

    #: Certificate valid to (expiration) date
    valid_to: TimeSinceEpoch

    #: List of signed certificate timestamps (SCTs).
    signed_certificate_timestamp_list: typing.List['SignedCertificateTimestamp']

    #: Whether the request complied with Certificate Transparency policy
    certificate_transparency_compliance: CertificateTransparencyCompliance

    @classmethod
    def from_response(cls, response):
        return cls(
            protocol=str(response.get('protocol')),
            key_exchange=str(response.get('keyExchange')),
            key_exchange_group=str(response.get('keyExchangeGroup')),
            cipher=str(response.get('cipher')),
            mac=str(response.get('mac')),
            certificate_id=security.CertificateId.from_response(response.get('certificateId')),
            subject_name=str(response.get('subjectName')),
            san_list=[str(i) for i in response.get('sanList')],
            issuer=str(response.get('issuer')),
            valid_from=TimeSinceEpoch.from_response(response.get('validFrom')),
            valid_to=TimeSinceEpoch.from_response(response.get('validTo')),
            signed_certificate_timestamp_list=[SignedCertificateTimestamp.from_response(i) for i in response.get('signedCertificateTimestampList')],
            certificate_transparency_compliance=CertificateTransparencyCompliance.from_response(response.get('certificateTransparencyCompliance')),
        )


@dataclass
class Response:
    '''
    HTTP response data.
    '''
    #: Response URL. This URL can be different from CachedResource.url in case of redirect.
    url: str

    #: HTTP response status code.
    status: int

    #: HTTP response status text.
    status_text: str

    #: HTTP response headers.
    headers: Headers

    #: HTTP response headers text.
    headers_text: str

    #: Resource mimeType as determined by the browser.
    mime_type: str

    #: Refined HTTP request headers that were actually transmitted over the network.
    request_headers: Headers

    #: HTTP request headers text.
    request_headers_text: str

    #: Specifies whether physical connection was actually reused for this request.
    connection_reused: bool

    #: Physical connection id that was actually used for this request.
    connection_id: float

    #: Remote IP address.
    remote_ip_address: str

    #: Remote port.
    remote_port: int

    #: Specifies that the request was served from the disk cache.
    from_disk_cache: bool

    #: Specifies that the request was served from the ServiceWorker.
    from_service_worker: bool

    #: Specifies that the request was served from the prefetch cache.
    from_prefetch_cache: bool

    #: Total number of bytes received for this request so far.
    encoded_data_length: float

    #: Timing information for the given request.
    timing: ResourceTiming

    #: Protocol used to fetch this request.
    protocol: str

    #: Security state of the request resource.
    security_state: security.SecurityState

    #: Security details for the request.
    security_details: SecurityDetails

    @classmethod
    def from_response(cls, response):
        return cls(
            url=str(response.get('url')),
            status=int(response.get('status')),
            status_text=str(response.get('statusText')),
            headers=Headers.from_response(response.get('headers')),
            headers_text=str(response.get('headersText')),
            mime_type=str(response.get('mimeType')),
            request_headers=Headers.from_response(response.get('requestHeaders')),
            request_headers_text=str(response.get('requestHeadersText')),
            connection_reused=bool(response.get('connectionReused')),
            connection_id=float(response.get('connectionId')),
            remote_ip_address=str(response.get('remoteIPAddress')),
            remote_port=int(response.get('remotePort')),
            from_disk_cache=bool(response.get('fromDiskCache')),
            from_service_worker=bool(response.get('fromServiceWorker')),
            from_prefetch_cache=bool(response.get('fromPrefetchCache')),
            encoded_data_length=float(response.get('encodedDataLength')),
            timing=ResourceTiming.from_response(response.get('timing')),
            protocol=str(response.get('protocol')),
            security_state=security.SecurityState.from_response(response.get('securityState')),
            security_details=SecurityDetails.from_response(response.get('securityDetails')),
        )


@dataclass
class WebSocketRequest:
    '''
    WebSocket request data.
    '''
    #: HTTP request headers.
    headers: Headers

    @classmethod
    def from_response(cls, response):
        return cls(
            headers=Headers.from_response(response.get('headers')),
        )


@dataclass
class WebSocketResponse:
    '''
    WebSocket response data.
    '''
    #: HTTP response status code.
    status: int

    #: HTTP response status text.
    status_text: str

    #: HTTP response headers.
    headers: Headers

    #: HTTP response headers text.
    headers_text: str

    #: HTTP request headers.
    request_headers: Headers

    #: HTTP request headers text.
    request_headers_text: str

    @classmethod
    def from_response(cls, response):
        return cls(
            status=int(response.get('status')),
            status_text=str(response.get('statusText')),
            headers=Headers.from_response(response.get('headers')),
            headers_text=str(response.get('headersText')),
            request_headers=Headers.from_response(response.get('requestHeaders')),
            request_headers_text=str(response.get('requestHeadersText')),
        )


@dataclass
class WebSocketFrame:
    '''
    WebSocket message data. This represents an entire WebSocket message, not just a fragmented frame as the name suggests.
    '''
    #: WebSocket message opcode.
    opcode: float

    #: WebSocket message mask.
    mask: bool

    #: WebSocket message payload data.
    #: If the opcode is 1, this is a text message and payloadData is a UTF-8 string.
    #: If the opcode isn't 1, then payloadData is a base64 encoded string representing binary data.
    payload_data: str

    @classmethod
    def from_response(cls, response):
        return cls(
            opcode=float(response.get('opcode')),
            mask=bool(response.get('mask')),
            payload_data=str(response.get('payloadData')),
        )


@dataclass
class CachedResource:
    '''
    Information about the cached resource.
    '''
    #: Resource URL. This is the url of the original network request.
    url: str

    #: Type of this resource.
    type_: ResourceType

    #: Cached response data.
    response: Response

    #: Cached response body size.
    body_size: float

    @classmethod
    def from_response(cls, response):
        return cls(
            url=str(response.get('url')),
            type_=ResourceType.from_response(response.get('type')),
            response=Response.from_response(response.get('response')),
            body_size=float(response.get('bodySize')),
        )


@dataclass
class Initiator:
    '''
    Information about the request initiator.
    '''
    #: Type of this initiator.
    type_: str

    #: Initiator JavaScript stack trace, set for Script only.
    stack: runtime.StackTrace

    #: Initiator URL, set for Parser type or for Script type (when script is importing module) or for SignedExchange type.
    url: str

    #: Initiator line number, set for Parser type or for Script type (when script is importing
    #: module) (0-based).
    line_number: float

    @classmethod
    def from_response(cls, response):
        return cls(
            type_=str(response.get('type')),
            stack=runtime.StackTrace.from_response(response.get('stack')),
            url=str(response.get('url')),
            line_number=float(response.get('lineNumber')),
        )


@dataclass
class Cookie:
    '''
    Cookie object
    '''
    #: Cookie name.
    name: str

    #: Cookie value.
    value: str

    #: Cookie domain.
    domain: str

    #: Cookie path.
    path: str

    #: Cookie expiration date as the number of seconds since the UNIX epoch.
    expires: float

    #: Cookie size.
    size: int

    #: True if cookie is http-only.
    http_only: bool

    #: True if cookie is secure.
    secure: bool

    #: True in case of session cookie.
    session: bool

    #: Cookie SameSite type.
    same_site: CookieSameSite

    @classmethod
    def from_response(cls, response):
        return cls(
            name=str(response.get('name')),
            value=str(response.get('value')),
            domain=str(response.get('domain')),
            path=str(response.get('path')),
            expires=float(response.get('expires')),
            size=int(response.get('size')),
            http_only=bool(response.get('httpOnly')),
            secure=bool(response.get('secure')),
            session=bool(response.get('session')),
            same_site=CookieSameSite.from_response(response.get('sameSite')),
        )


@dataclass
class CookieParam:
    '''
    Cookie parameter object
    '''
    #: Cookie name.
    name: str

    #: Cookie value.
    value: str

    #: The request-URI to associate with the setting of the cookie. This value can affect the
    #: default domain and path values of the created cookie.
    url: str

    #: Cookie domain.
    domain: str

    #: Cookie path.
    path: str

    #: True if cookie is secure.
    secure: bool

    #: True if cookie is http-only.
    http_only: bool

    #: Cookie SameSite type.
    same_site: CookieSameSite

    #: Cookie expiration date, session cookie if not set
    expires: TimeSinceEpoch

    @classmethod
    def from_response(cls, response):
        return cls(
            name=str(response.get('name')),
            value=str(response.get('value')),
            url=str(response.get('url')),
            domain=str(response.get('domain')),
            path=str(response.get('path')),
            secure=bool(response.get('secure')),
            http_only=bool(response.get('httpOnly')),
            same_site=CookieSameSite.from_response(response.get('sameSite')),
            expires=TimeSinceEpoch.from_response(response.get('expires')),
        )


@dataclass
class AuthChallenge:
    '''
    Authorization challenge for HTTP status code 401 or 407.
    '''
    #: Source of the authentication challenge.
    source: str

    #: Origin of the challenger.
    origin: str

    #: The authentication scheme used, such as basic or digest
    scheme: str

    #: The realm of the challenge. May be empty.
    realm: str

    @classmethod
    def from_response(cls, response):
        return cls(
            source=str(response.get('source')),
            origin=str(response.get('origin')),
            scheme=str(response.get('scheme')),
            realm=str(response.get('realm')),
        )


@dataclass
class AuthChallengeResponse:
    '''
    Response to an AuthChallenge.
    '''
    #: The decision on what to do in response to the authorization challenge.  Default means
    #: deferring to the default behavior of the net stack, which will likely either the Cancel
    #: authentication or display a popup dialog box.
    response: str

    #: The username to provide, possibly empty. Should only be set if response is
    #: ProvideCredentials.
    username: str

    #: The password to provide, possibly empty. Should only be set if response is
    #: ProvideCredentials.
    password: str

    @classmethod
    def from_response(cls, response):
        return cls(
            response=str(response.get('response')),
            username=str(response.get('username')),
            password=str(response.get('password')),
        )


@dataclass
class RequestPattern:
    '''
    Request pattern for interception.
    '''
    #: Wildcards ('*' -> zero or more, '?' -> exactly one) are allowed. Escape character is
    #: backslash. Omitting is equivalent to "*".
    url_pattern: str

    #: If set, only requests for matching resource types will be intercepted.
    resource_type: ResourceType

    #: Stage at wich to begin intercepting requests. Default is Request.
    interception_stage: InterceptionStage

    @classmethod
    def from_response(cls, response):
        return cls(
            url_pattern=str(response.get('urlPattern')),
            resource_type=ResourceType.from_response(response.get('resourceType')),
            interception_stage=InterceptionStage.from_response(response.get('interceptionStage')),
        )


@dataclass
class SignedExchangeSignature:
    '''
    Information about a signed exchange signature.
    https://wicg.github.io/webpackage/draft-yasskin-httpbis-origin-signed-exchanges-impl.html#rfc.section.3.1
    '''
    #: Signed exchange signature label.
    label: str

    #: The hex string of signed exchange signature.
    signature: str

    #: Signed exchange signature integrity.
    integrity: str

    #: Signed exchange signature cert Url.
    cert_url: str

    #: The hex string of signed exchange signature cert sha256.
    cert_sha256: str

    #: Signed exchange signature validity Url.
    validity_url: str

    #: Signed exchange signature date.
    date: int

    #: Signed exchange signature expires.
    expires: int

    #: The encoded certificates.
    certificates: typing.List

    @classmethod
    def from_response(cls, response):
        return cls(
            label=str(response.get('label')),
            signature=str(response.get('signature')),
            integrity=str(response.get('integrity')),
            cert_url=str(response.get('certUrl')),
            cert_sha256=str(response.get('certSha256')),
            validity_url=str(response.get('validityUrl')),
            date=int(response.get('date')),
            expires=int(response.get('expires')),
            certificates=[str(i) for i in response.get('certificates')],
        )


@dataclass
class SignedExchangeHeader:
    '''
    Information about a signed exchange header.
    https://wicg.github.io/webpackage/draft-yasskin-httpbis-origin-signed-exchanges-impl.html#cbor-representation
    '''
    #: Signed exchange request URL.
    request_url: str

    #: Signed exchange response code.
    response_code: int

    #: Signed exchange response headers.
    response_headers: Headers

    #: Signed exchange response signature.
    signatures: typing.List['SignedExchangeSignature']

    @classmethod
    def from_response(cls, response):
        return cls(
            request_url=str(response.get('requestUrl')),
            response_code=int(response.get('responseCode')),
            response_headers=Headers.from_response(response.get('responseHeaders')),
            signatures=[SignedExchangeSignature.from_response(i) for i in response.get('signatures')],
        )


@dataclass
class SignedExchangeError:
    '''
    Information about a signed exchange response.
    '''
    #: Error message.
    message: str

    #: The index of the signature which caused the error.
    signature_index: int

    #: The field which caused the error.
    error_field: SignedExchangeErrorField

    @classmethod
    def from_response(cls, response):
        return cls(
            message=str(response.get('message')),
            signature_index=int(response.get('signatureIndex')),
            error_field=SignedExchangeErrorField.from_response(response.get('errorField')),
        )


@dataclass
class SignedExchangeInfo:
    '''
    Information about a signed exchange response.
    '''
    #: The outer response of signed HTTP exchange which was received from network.
    outer_response: Response

    #: Information about the signed exchange header.
    header: SignedExchangeHeader

    #: Security details for the signed exchange header.
    security_details: SecurityDetails

    #: Errors occurred while handling the signed exchagne.
    errors: typing.List['SignedExchangeError']

    @classmethod
    def from_response(cls, response):
        return cls(
            outer_response=Response.from_response(response.get('outerResponse')),
            header=SignedExchangeHeader.from_response(response.get('header')),
            security_details=SecurityDetails.from_response(response.get('securityDetails')),
            errors=[SignedExchangeError.from_response(i) for i in response.get('errors')],
        )

