'''
DO NOT EDIT THIS FILE

This file is generated from the CDP definitions. If you need to make changes,
edit the generator and regenerate all of the modules.

Domain: network
Experimental: False
'''

from cdp.util import T_JSON_DICT
from dataclasses import dataclass
import enum
import typing

from ..runtime import types as runtime
from ..security import types as security


class ResourceType(enum.Enum):
    '''
    Resource type as it was perceived by the rendering engine.
    '''
    DOCUMENT = "Document"
    STYLESHEET = "Stylesheet"
    IMAGE = "Image"
    MEDIA = "Media"
    FONT = "Font"
    SCRIPT = "Script"
    TEXT_TRACK = "TextTrack"
    XHR = "XHR"
    FETCH = "Fetch"
    EVENT_SOURCE = "EventSource"
    WEB_SOCKET = "WebSocket"
    MANIFEST = "Manifest"
    SIGNED_EXCHANGE = "SignedExchange"
    PING = "Ping"
    CSP_VIOLATION_REPORT = "CSPViolationReport"
    OTHER = "Other"

    def to_json(self) -> str:
        return self.value

    @classmethod
    def from_json(cls, json: str) -> 'ResourceType':
        return cls(json)


class LoaderId(str):
    '''
    Unique loader identifier.
    '''
    def to_json(self) -> str:
        return self

    @classmethod
    def from_json(cls, json: str) -> 'LoaderId':
        return cls(json)

    def __repr__(self):
        return 'LoaderId({})'.format(str.__repr__(self))


class RequestId(str):
    '''
    Unique request identifier.
    '''
    def to_json(self) -> str:
        return self

    @classmethod
    def from_json(cls, json: str) -> 'RequestId':
        return cls(json)

    def __repr__(self):
        return 'RequestId({})'.format(str.__repr__(self))


class InterceptionId(str):
    '''
    Unique intercepted request identifier.
    '''
    def to_json(self) -> str:
        return self

    @classmethod
    def from_json(cls, json: str) -> 'InterceptionId':
        return cls(json)

    def __repr__(self):
        return 'InterceptionId({})'.format(str.__repr__(self))


class ErrorReason(enum.Enum):
    '''
    Network level fetch failure reason.
    '''
    FAILED = "Failed"
    ABORTED = "Aborted"
    TIMED_OUT = "TimedOut"
    ACCESS_DENIED = "AccessDenied"
    CONNECTION_CLOSED = "ConnectionClosed"
    CONNECTION_RESET = "ConnectionReset"
    CONNECTION_REFUSED = "ConnectionRefused"
    CONNECTION_ABORTED = "ConnectionAborted"
    CONNECTION_FAILED = "ConnectionFailed"
    NAME_NOT_RESOLVED = "NameNotResolved"
    INTERNET_DISCONNECTED = "InternetDisconnected"
    ADDRESS_UNREACHABLE = "AddressUnreachable"
    BLOCKED_BY_CLIENT = "BlockedByClient"
    BLOCKED_BY_RESPONSE = "BlockedByResponse"

    def to_json(self) -> str:
        return self.value

    @classmethod
    def from_json(cls, json: str) -> 'ErrorReason':
        return cls(json)


class TimeSinceEpoch(float):
    '''
    UTC time in seconds, counted from January 1, 1970.
    '''
    def to_json(self) -> float:
        return self

    @classmethod
    def from_json(cls, json: float) -> 'TimeSinceEpoch':
        return cls(json)

    def __repr__(self):
        return 'TimeSinceEpoch({})'.format(float.__repr__(self))


class MonotonicTime(float):
    '''
    Monotonically increasing time in seconds since an arbitrary point in the past.
    '''
    def to_json(self) -> float:
        return self

    @classmethod
    def from_json(cls, json: float) -> 'MonotonicTime':
        return cls(json)

    def __repr__(self):
        return 'MonotonicTime({})'.format(float.__repr__(self))


class ConnectionType(enum.Enum):
    '''
    The underlying connection technology that the browser is supposedly using.
    '''
    NONE = "none"
    CELLULAR2G = "cellular2g"
    CELLULAR3G = "cellular3g"
    CELLULAR4G = "cellular4g"
    BLUETOOTH = "bluetooth"
    ETHERNET = "ethernet"
    WIFI = "wifi"
    WIMAX = "wimax"
    OTHER = "other"

    def to_json(self) -> str:
        return self.value

    @classmethod
    def from_json(cls, json: str) -> 'ConnectionType':
        return cls(json)


class CookieSameSite(enum.Enum):
    '''
    Represents the cookie's 'SameSite' status:
    https://tools.ietf.org/html/draft-west-first-party-cookies
    '''
    STRICT = "Strict"
    LAX = "Lax"
    EXTENDED = "Extended"
    NONE = "None"

    def to_json(self) -> str:
        return self.value

    @classmethod
    def from_json(cls, json: str) -> 'CookieSameSite':
        return cls(json)


class ResourcePriority(enum.Enum):
    '''
    Loading priority of a resource request.
    '''
    VERY_LOW = "VeryLow"
    LOW = "Low"
    MEDIUM = "Medium"
    HIGH = "High"
    VERY_HIGH = "VeryHigh"

    def to_json(self) -> str:
        return self.value

    @classmethod
    def from_json(cls, json: str) -> 'ResourcePriority':
        return cls(json)


class CertificateTransparencyCompliance(enum.Enum):
    '''
    Whether the request complied with Certificate Transparency policy.
    '''
    UNKNOWN = "unknown"
    NOT_COMPLIANT = "not-compliant"
    COMPLIANT = "compliant"

    def to_json(self) -> str:
        return self.value

    @classmethod
    def from_json(cls, json: str) -> 'CertificateTransparencyCompliance':
        return cls(json)


class BlockedReason(enum.Enum):
    '''
    The reason why request was blocked.
    '''
    OTHER = "other"
    CSP = "csp"
    MIXED_CONTENT = "mixed-content"
    ORIGIN = "origin"
    INSPECTOR = "inspector"
    SUBRESOURCE_FILTER = "subresource-filter"
    CONTENT_TYPE = "content-type"
    COLLAPSED_BY_CLIENT = "collapsed-by-client"

    def to_json(self) -> str:
        return self.value

    @classmethod
    def from_json(cls, json: str) -> 'BlockedReason':
        return cls(json)


class InterceptionStage(enum.Enum):
    '''
    Stages of the interception to begin intercepting. Request will intercept before the request is
    sent. Response will intercept after the response is received.
    '''
    REQUEST = "Request"
    HEADERS_RECEIVED = "HeadersReceived"

    def to_json(self) -> str:
        return self.value

    @classmethod
    def from_json(cls, json: str) -> 'InterceptionStage':
        return cls(json)


class SignedExchangeErrorField(enum.Enum):
    '''
    Field type for a signed exchange related error.
    '''
    SIGNATURE_SIG = "signatureSig"
    SIGNATURE_INTEGRITY = "signatureIntegrity"
    SIGNATURE_CERT_URL = "signatureCertUrl"
    SIGNATURE_CERT_SHA256 = "signatureCertSha256"
    SIGNATURE_VALIDITY_URL = "signatureValidityUrl"
    SIGNATURE_TIMESTAMPS = "signatureTimestamps"

    def to_json(self) -> str:
        return self.value

    @classmethod
    def from_json(cls, json: str) -> 'SignedExchangeErrorField':
        return cls(json)


@dataclass
class Headers:
    '''
    Request / response headers as keys / values of JSON object.
    '''
    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {
        }
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> 'Headers':
        return cls(
        )

@dataclass
class ResourceTiming:
    '''
    Timing information for the request.
    '''
    #: Timing's requestTime is a baseline in seconds, while the other numbers are ticks in
    #: milliseconds relatively to this requestTime.
    request_time: float

    #: Started resolving proxy.
    proxy_start: float

    #: Finished resolving proxy.
    proxy_end: float

    #: Started DNS address resolve.
    dns_start: float

    #: Finished DNS address resolve.
    dns_end: float

    #: Started connecting to the remote host.
    connect_start: float

    #: Connected to the remote host.
    connect_end: float

    #: Started SSL handshake.
    ssl_start: float

    #: Finished SSL handshake.
    ssl_end: float

    #: Started running ServiceWorker.
    worker_start: float

    #: Finished Starting ServiceWorker.
    worker_ready: float

    #: Started sending request.
    send_start: float

    #: Finished sending request.
    send_end: float

    #: Time the server started pushing request.
    push_start: float

    #: Time the server finished pushing request.
    push_end: float

    #: Finished receiving response headers.
    receive_headers_end: float

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {
            'requestTime': self.request_time,
            'proxyStart': self.proxy_start,
            'proxyEnd': self.proxy_end,
            'dnsStart': self.dns_start,
            'dnsEnd': self.dns_end,
            'connectStart': self.connect_start,
            'connectEnd': self.connect_end,
            'sslStart': self.ssl_start,
            'sslEnd': self.ssl_end,
            'workerStart': self.worker_start,
            'workerReady': self.worker_ready,
            'sendStart': self.send_start,
            'sendEnd': self.send_end,
            'pushStart': self.push_start,
            'pushEnd': self.push_end,
            'receiveHeadersEnd': self.receive_headers_end,
        }
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> 'ResourceTiming':
        return cls(
            request_time=json['requestTime'],
            proxy_start=json['proxyStart'],
            proxy_end=json['proxyEnd'],
            dns_start=json['dnsStart'],
            dns_end=json['dnsEnd'],
            connect_start=json['connectStart'],
            connect_end=json['connectEnd'],
            ssl_start=json['sslStart'],
            ssl_end=json['sslEnd'],
            worker_start=json['workerStart'],
            worker_ready=json['workerReady'],
            send_start=json['sendStart'],
            send_end=json['sendEnd'],
            push_start=json['pushStart'],
            push_end=json['pushEnd'],
            receive_headers_end=json['receiveHeadersEnd'],
        )

@dataclass
class Request:
    '''
    HTTP request data.
    '''
    #: Request URL (without fragment).
    url: str

    #: HTTP request method.
    method: str

    #: HTTP request headers.
    headers: Headers

    #: Priority of the resource request at the time request is sent.
    initial_priority: ResourcePriority

    #: The referrer policy of the request, as defined in https://www.w3.org/TR/referrer-policy/
    referrer_policy: str

    #: Fragment of the requested URL starting with hash, if present.
    url_fragment: typing.Optional[str] = None

    #: HTTP POST request data.
    post_data: typing.Optional[str] = None

    #: True when the request has POST data. Note that postData might still be omitted when this flag is true when the data is too long.
    has_post_data: typing.Optional[bool] = None

    #: The mixed content type of the request.
    mixed_content_type: typing.Optional[security.MixedContentType] = None

    #: Whether is loaded via link preload.
    is_link_preload: typing.Optional[bool] = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {
            'url': self.url,
            'method': self.method,
            'headers': self.headers.to_json(),
            'initialPriority': self.initial_priority.to_json(),
            'referrerPolicy': self.referrer_policy,
        }
        if self.url_fragment is not None:
            json['urlFragment'] = self.url_fragment
        if self.post_data is not None:
            json['postData'] = self.post_data
        if self.has_post_data is not None:
            json['hasPostData'] = self.has_post_data
        if self.mixed_content_type is not None:
            json['mixedContentType'] = self.mixed_content_type.to_json()
        if self.is_link_preload is not None:
            json['isLinkPreload'] = self.is_link_preload
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> 'Request':
        url_fragment = json['urlFragment'] if 'urlFragment' in json else None
        post_data = json['postData'] if 'postData' in json else None
        has_post_data = json['hasPostData'] if 'hasPostData' in json else None
        mixed_content_type = security.MixedContentType.from_json(json['mixedContentType']) if 'mixedContentType' in json else None
        is_link_preload = json['isLinkPreload'] if 'isLinkPreload' in json else None
        return cls(
            url=json['url'],
            url_fragment=url_fragment,
            method=json['method'],
            headers=Headers.from_json(json['headers']),
            post_data=post_data,
            has_post_data=has_post_data,
            mixed_content_type=mixed_content_type,
            initial_priority=ResourcePriority.from_json(json['initialPriority']),
            referrer_policy=json['referrerPolicy'],
            is_link_preload=is_link_preload,
        )

@dataclass
class SignedCertificateTimestamp:
    '''
    Details of a signed certificate timestamp (SCT).
    '''
    #: Validation status.
    status: str

    #: Origin.
    origin: str

    #: Log name / description.
    log_description: str

    #: Log ID.
    log_id: str

    #: Issuance date.
    timestamp: TimeSinceEpoch

    #: Hash algorithm.
    hash_algorithm: str

    #: Signature algorithm.
    signature_algorithm: str

    #: Signature data.
    signature_data: str

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {
            'status': self.status,
            'origin': self.origin,
            'logDescription': self.log_description,
            'logId': self.log_id,
            'timestamp': self.timestamp.to_json(),
            'hashAlgorithm': self.hash_algorithm,
            'signatureAlgorithm': self.signature_algorithm,
            'signatureData': self.signature_data,
        }
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> 'SignedCertificateTimestamp':
        return cls(
            status=json['status'],
            origin=json['origin'],
            log_description=json['logDescription'],
            log_id=json['logId'],
            timestamp=TimeSinceEpoch.from_json(json['timestamp']),
            hash_algorithm=json['hashAlgorithm'],
            signature_algorithm=json['signatureAlgorithm'],
            signature_data=json['signatureData'],
        )

@dataclass
class SecurityDetails:
    '''
    Security details about a request.
    '''
    #: Protocol name (e.g. "TLS 1.2" or "QUIC").
    protocol: str

    #: Key Exchange used by the connection, or the empty string if not applicable.
    key_exchange: str

    #: Cipher name.
    cipher: str

    #: Certificate ID value.
    certificate_id: security.CertificateId

    #: Certificate subject name.
    subject_name: str

    #: Subject Alternative Name (SAN) DNS names and IP addresses.
    san_list: typing.List['str']

    #: Name of the issuing CA.
    issuer: str

    #: Certificate valid from date.
    valid_from: TimeSinceEpoch

    #: Certificate valid to (expiration) date
    valid_to: TimeSinceEpoch

    #: List of signed certificate timestamps (SCTs).
    signed_certificate_timestamp_list: typing.List['SignedCertificateTimestamp']

    #: Whether the request complied with Certificate Transparency policy
    certificate_transparency_compliance: CertificateTransparencyCompliance

    #: (EC)DH group used by the connection, if applicable.
    key_exchange_group: typing.Optional[str] = None

    #: TLS MAC. Note that AEAD ciphers do not have separate MACs.
    mac: typing.Optional[str] = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {
            'protocol': self.protocol,
            'keyExchange': self.key_exchange,
            'cipher': self.cipher,
            'certificateId': self.certificate_id.to_json(),
            'subjectName': self.subject_name,
            'sanList': [i for i in self.san_list],
            'issuer': self.issuer,
            'validFrom': self.valid_from.to_json(),
            'validTo': self.valid_to.to_json(),
            'signedCertificateTimestampList': [i.to_json() for i in self.signed_certificate_timestamp_list],
            'certificateTransparencyCompliance': self.certificate_transparency_compliance.to_json(),
        }
        if self.key_exchange_group is not None:
            json['keyExchangeGroup'] = self.key_exchange_group
        if self.mac is not None:
            json['mac'] = self.mac
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> 'SecurityDetails':
        key_exchange_group = json['keyExchangeGroup'] if 'keyExchangeGroup' in json else None
        mac = json['mac'] if 'mac' in json else None
        return cls(
            protocol=json['protocol'],
            key_exchange=json['keyExchange'],
            key_exchange_group=key_exchange_group,
            cipher=json['cipher'],
            mac=mac,
            certificate_id=security.CertificateId.from_json(json['certificateId']),
            subject_name=json['subjectName'],
            san_list=[i for i in json['sanList']],
            issuer=json['issuer'],
            valid_from=TimeSinceEpoch.from_json(json['validFrom']),
            valid_to=TimeSinceEpoch.from_json(json['validTo']),
            signed_certificate_timestamp_list=[SignedCertificateTimestamp.from_json(i) for i in json['signedCertificateTimestampList']],
            certificate_transparency_compliance=CertificateTransparencyCompliance.from_json(json['certificateTransparencyCompliance']),
        )

@dataclass
class Response:
    '''
    HTTP response data.
    '''
    #: Response URL. This URL can be different from CachedResource.url in case of redirect.
    url: str

    #: HTTP response status code.
    status: int

    #: HTTP response status text.
    status_text: str

    #: HTTP response headers.
    headers: Headers

    #: Resource mimeType as determined by the browser.
    mime_type: str

    #: Specifies whether physical connection was actually reused for this request.
    connection_reused: bool

    #: Physical connection id that was actually used for this request.
    connection_id: float

    #: Total number of bytes received for this request so far.
    encoded_data_length: float

    #: Security state of the request resource.
    security_state: security.SecurityState

    #: HTTP response headers text.
    headers_text: typing.Optional[str] = None

    #: Refined HTTP request headers that were actually transmitted over the network.
    request_headers: typing.Optional[Headers] = None

    #: HTTP request headers text.
    request_headers_text: typing.Optional[str] = None

    #: Remote IP address.
    remote_ip_address: typing.Optional[str] = None

    #: Remote port.
    remote_port: typing.Optional[int] = None

    #: Specifies that the request was served from the disk cache.
    from_disk_cache: typing.Optional[bool] = None

    #: Specifies that the request was served from the ServiceWorker.
    from_service_worker: typing.Optional[bool] = None

    #: Specifies that the request was served from the prefetch cache.
    from_prefetch_cache: typing.Optional[bool] = None

    #: Timing information for the given request.
    timing: typing.Optional[ResourceTiming] = None

    #: Protocol used to fetch this request.
    protocol: typing.Optional[str] = None

    #: Security details for the request.
    security_details: typing.Optional[SecurityDetails] = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {
            'url': self.url,
            'status': self.status,
            'statusText': self.status_text,
            'headers': self.headers.to_json(),
            'mimeType': self.mime_type,
            'connectionReused': self.connection_reused,
            'connectionId': self.connection_id,
            'encodedDataLength': self.encoded_data_length,
            'securityState': self.security_state.to_json(),
        }
        if self.headers_text is not None:
            json['headersText'] = self.headers_text
        if self.request_headers is not None:
            json['requestHeaders'] = self.request_headers.to_json()
        if self.request_headers_text is not None:
            json['requestHeadersText'] = self.request_headers_text
        if self.remote_ip_address is not None:
            json['remoteIPAddress'] = self.remote_ip_address
        if self.remote_port is not None:
            json['remotePort'] = self.remote_port
        if self.from_disk_cache is not None:
            json['fromDiskCache'] = self.from_disk_cache
        if self.from_service_worker is not None:
            json['fromServiceWorker'] = self.from_service_worker
        if self.from_prefetch_cache is not None:
            json['fromPrefetchCache'] = self.from_prefetch_cache
        if self.timing is not None:
            json['timing'] = self.timing.to_json()
        if self.protocol is not None:
            json['protocol'] = self.protocol
        if self.security_details is not None:
            json['securityDetails'] = self.security_details.to_json()
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> 'Response':
        headers_text = json['headersText'] if 'headersText' in json else None
        request_headers = Headers.from_json(json['requestHeaders']) if 'requestHeaders' in json else None
        request_headers_text = json['requestHeadersText'] if 'requestHeadersText' in json else None
        remote_ip_address = json['remoteIPAddress'] if 'remoteIPAddress' in json else None
        remote_port = json['remotePort'] if 'remotePort' in json else None
        from_disk_cache = json['fromDiskCache'] if 'fromDiskCache' in json else None
        from_service_worker = json['fromServiceWorker'] if 'fromServiceWorker' in json else None
        from_prefetch_cache = json['fromPrefetchCache'] if 'fromPrefetchCache' in json else None
        timing = ResourceTiming.from_json(json['timing']) if 'timing' in json else None
        protocol = json['protocol'] if 'protocol' in json else None
        security_details = SecurityDetails.from_json(json['securityDetails']) if 'securityDetails' in json else None
        return cls(
            url=json['url'],
            status=json['status'],
            status_text=json['statusText'],
            headers=Headers.from_json(json['headers']),
            headers_text=headers_text,
            mime_type=json['mimeType'],
            request_headers=request_headers,
            request_headers_text=request_headers_text,
            connection_reused=json['connectionReused'],
            connection_id=json['connectionId'],
            remote_ip_address=remote_ip_address,
            remote_port=remote_port,
            from_disk_cache=from_disk_cache,
            from_service_worker=from_service_worker,
            from_prefetch_cache=from_prefetch_cache,
            encoded_data_length=json['encodedDataLength'],
            timing=timing,
            protocol=protocol,
            security_state=security.SecurityState.from_json(json['securityState']),
            security_details=security_details,
        )

@dataclass
class WebSocketRequest:
    '''
    WebSocket request data.
    '''
    #: HTTP request headers.
    headers: Headers

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {
            'headers': self.headers.to_json(),
        }
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> 'WebSocketRequest':
        return cls(
            headers=Headers.from_json(json['headers']),
        )

@dataclass
class WebSocketResponse:
    '''
    WebSocket response data.
    '''
    #: HTTP response status code.
    status: int

    #: HTTP response status text.
    status_text: str

    #: HTTP response headers.
    headers: Headers

    #: HTTP response headers text.
    headers_text: typing.Optional[str] = None

    #: HTTP request headers.
    request_headers: typing.Optional[Headers] = None

    #: HTTP request headers text.
    request_headers_text: typing.Optional[str] = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {
            'status': self.status,
            'statusText': self.status_text,
            'headers': self.headers.to_json(),
        }
        if self.headers_text is not None:
            json['headersText'] = self.headers_text
        if self.request_headers is not None:
            json['requestHeaders'] = self.request_headers.to_json()
        if self.request_headers_text is not None:
            json['requestHeadersText'] = self.request_headers_text
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> 'WebSocketResponse':
        headers_text = json['headersText'] if 'headersText' in json else None
        request_headers = Headers.from_json(json['requestHeaders']) if 'requestHeaders' in json else None
        request_headers_text = json['requestHeadersText'] if 'requestHeadersText' in json else None
        return cls(
            status=json['status'],
            status_text=json['statusText'],
            headers=Headers.from_json(json['headers']),
            headers_text=headers_text,
            request_headers=request_headers,
            request_headers_text=request_headers_text,
        )

@dataclass
class WebSocketFrame:
    '''
    WebSocket message data. This represents an entire WebSocket message, not just a fragmented frame as the name suggests.
    '''
    #: WebSocket message opcode.
    opcode: float

    #: WebSocket message mask.
    mask: bool

    #: WebSocket message payload data.
    #: If the opcode is 1, this is a text message and payloadData is a UTF-8 string.
    #: If the opcode isn't 1, then payloadData is a base64 encoded string representing binary data.
    payload_data: str

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {
            'opcode': self.opcode,
            'mask': self.mask,
            'payloadData': self.payload_data,
        }
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> 'WebSocketFrame':
        return cls(
            opcode=json['opcode'],
            mask=json['mask'],
            payload_data=json['payloadData'],
        )

@dataclass
class CachedResource:
    '''
    Information about the cached resource.
    '''
    #: Resource URL. This is the url of the original network request.
    url: str

    #: Type of this resource.
    type: ResourceType

    #: Cached response body size.
    body_size: float

    #: Cached response data.
    response: typing.Optional[Response] = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {
            'url': self.url,
            'type': self.type.to_json(),
            'bodySize': self.body_size,
        }
        if self.response is not None:
            json['response'] = self.response.to_json()
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> 'CachedResource':
        response = Response.from_json(json['response']) if 'response' in json else None
        return cls(
            url=json['url'],
            type=ResourceType.from_json(json['type']),
            response=response,
            body_size=json['bodySize'],
        )

@dataclass
class Initiator:
    '''
    Information about the request initiator.
    '''
    #: Type of this initiator.
    type: str

    #: Initiator JavaScript stack trace, set for Script only.
    stack: typing.Optional[runtime.StackTrace] = None

    #: Initiator URL, set for Parser type or for Script type (when script is importing module) or for SignedExchange type.
    url: typing.Optional[str] = None

    #: Initiator line number, set for Parser type or for Script type (when script is importing
    #: module) (0-based).
    line_number: typing.Optional[float] = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {
            'type': self.type,
        }
        if self.stack is not None:
            json['stack'] = self.stack.to_json()
        if self.url is not None:
            json['url'] = self.url
        if self.line_number is not None:
            json['lineNumber'] = self.line_number
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> 'Initiator':
        stack = runtime.StackTrace.from_json(json['stack']) if 'stack' in json else None
        url = json['url'] if 'url' in json else None
        line_number = json['lineNumber'] if 'lineNumber' in json else None
        return cls(
            type=json['type'],
            stack=stack,
            url=url,
            line_number=line_number,
        )

@dataclass
class Cookie:
    '''
    Cookie object
    '''
    #: Cookie name.
    name: str

    #: Cookie value.
    value: str

    #: Cookie domain.
    domain: str

    #: Cookie path.
    path: str

    #: Cookie expiration date as the number of seconds since the UNIX epoch.
    expires: float

    #: Cookie size.
    size: int

    #: True if cookie is http-only.
    http_only: bool

    #: True if cookie is secure.
    secure: bool

    #: True in case of session cookie.
    session: bool

    #: Cookie SameSite type.
    same_site: typing.Optional[CookieSameSite] = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {
            'name': self.name,
            'value': self.value,
            'domain': self.domain,
            'path': self.path,
            'expires': self.expires,
            'size': self.size,
            'httpOnly': self.http_only,
            'secure': self.secure,
            'session': self.session,
        }
        if self.same_site is not None:
            json['sameSite'] = self.same_site.to_json()
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> 'Cookie':
        same_site = CookieSameSite.from_json(json['sameSite']) if 'sameSite' in json else None
        return cls(
            name=json['name'],
            value=json['value'],
            domain=json['domain'],
            path=json['path'],
            expires=json['expires'],
            size=json['size'],
            http_only=json['httpOnly'],
            secure=json['secure'],
            session=json['session'],
            same_site=same_site,
        )

@dataclass
class CookieParam:
    '''
    Cookie parameter object
    '''
    #: Cookie name.
    name: str

    #: Cookie value.
    value: str

    #: The request-URI to associate with the setting of the cookie. This value can affect the
    #: default domain and path values of the created cookie.
    url: typing.Optional[str] = None

    #: Cookie domain.
    domain: typing.Optional[str] = None

    #: Cookie path.
    path: typing.Optional[str] = None

    #: True if cookie is secure.
    secure: typing.Optional[bool] = None

    #: True if cookie is http-only.
    http_only: typing.Optional[bool] = None

    #: Cookie SameSite type.
    same_site: typing.Optional[CookieSameSite] = None

    #: Cookie expiration date, session cookie if not set
    expires: typing.Optional[TimeSinceEpoch] = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {
            'name': self.name,
            'value': self.value,
        }
        if self.url is not None:
            json['url'] = self.url
        if self.domain is not None:
            json['domain'] = self.domain
        if self.path is not None:
            json['path'] = self.path
        if self.secure is not None:
            json['secure'] = self.secure
        if self.http_only is not None:
            json['httpOnly'] = self.http_only
        if self.same_site is not None:
            json['sameSite'] = self.same_site.to_json()
        if self.expires is not None:
            json['expires'] = self.expires.to_json()
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> 'CookieParam':
        url = json['url'] if 'url' in json else None
        domain = json['domain'] if 'domain' in json else None
        path = json['path'] if 'path' in json else None
        secure = json['secure'] if 'secure' in json else None
        http_only = json['httpOnly'] if 'httpOnly' in json else None
        same_site = CookieSameSite.from_json(json['sameSite']) if 'sameSite' in json else None
        expires = TimeSinceEpoch.from_json(json['expires']) if 'expires' in json else None
        return cls(
            name=json['name'],
            value=json['value'],
            url=url,
            domain=domain,
            path=path,
            secure=secure,
            http_only=http_only,
            same_site=same_site,
            expires=expires,
        )

@dataclass
class AuthChallenge:
    '''
    Authorization challenge for HTTP status code 401 or 407.
    '''
    #: Origin of the challenger.
    origin: str

    #: The authentication scheme used, such as basic or digest
    scheme: str

    #: The realm of the challenge. May be empty.
    realm: str

    #: Source of the authentication challenge.
    source: typing.Optional[str] = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {
            'origin': self.origin,
            'scheme': self.scheme,
            'realm': self.realm,
        }
        if self.source is not None:
            json['source'] = self.source
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> 'AuthChallenge':
        source = json['source'] if 'source' in json else None
        return cls(
            source=source,
            origin=json['origin'],
            scheme=json['scheme'],
            realm=json['realm'],
        )

@dataclass
class AuthChallengeResponse:
    '''
    Response to an AuthChallenge.
    '''
    #: The decision on what to do in response to the authorization challenge.  Default means
    #: deferring to the default behavior of the net stack, which will likely either the Cancel
    #: authentication or display a popup dialog box.
    response: str

    #: The username to provide, possibly empty. Should only be set if response is
    #: ProvideCredentials.
    username: typing.Optional[str] = None

    #: The password to provide, possibly empty. Should only be set if response is
    #: ProvideCredentials.
    password: typing.Optional[str] = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {
            'response': self.response,
        }
        if self.username is not None:
            json['username'] = self.username
        if self.password is not None:
            json['password'] = self.password
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> 'AuthChallengeResponse':
        username = json['username'] if 'username' in json else None
        password = json['password'] if 'password' in json else None
        return cls(
            response=json['response'],
            username=username,
            password=password,
        )

@dataclass
class RequestPattern:
    '''
    Request pattern for interception.
    '''
    #: Wildcards ('*' -> zero or more, '?' -> exactly one) are allowed. Escape character is
    #: backslash. Omitting is equivalent to "*".
    url_pattern: typing.Optional[str] = None

    #: If set, only requests for matching resource types will be intercepted.
    resource_type: typing.Optional[ResourceType] = None

    #: Stage at wich to begin intercepting requests. Default is Request.
    interception_stage: typing.Optional[InterceptionStage] = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {
        }
        if self.url_pattern is not None:
            json['urlPattern'] = self.url_pattern
        if self.resource_type is not None:
            json['resourceType'] = self.resource_type.to_json()
        if self.interception_stage is not None:
            json['interceptionStage'] = self.interception_stage.to_json()
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> 'RequestPattern':
        url_pattern = json['urlPattern'] if 'urlPattern' in json else None
        resource_type = ResourceType.from_json(json['resourceType']) if 'resourceType' in json else None
        interception_stage = InterceptionStage.from_json(json['interceptionStage']) if 'interceptionStage' in json else None
        return cls(
            url_pattern=url_pattern,
            resource_type=resource_type,
            interception_stage=interception_stage,
        )

@dataclass
class SignedExchangeSignature:
    '''
    Information about a signed exchange signature.
    https://wicg.github.io/webpackage/draft-yasskin-httpbis-origin-signed-exchanges-impl.html#rfc.section.3.1
    '''
    #: Signed exchange signature label.
    label: str

    #: The hex string of signed exchange signature.
    signature: str

    #: Signed exchange signature integrity.
    integrity: str

    #: Signed exchange signature validity Url.
    validity_url: str

    #: Signed exchange signature date.
    date: int

    #: Signed exchange signature expires.
    expires: int

    #: Signed exchange signature cert Url.
    cert_url: typing.Optional[str] = None

    #: The hex string of signed exchange signature cert sha256.
    cert_sha256: typing.Optional[str] = None

    #: The encoded certificates.
    certificates: typing.Optional[typing.List['str']] = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {
            'label': self.label,
            'signature': self.signature,
            'integrity': self.integrity,
            'validityUrl': self.validity_url,
            'date': self.date,
            'expires': self.expires,
        }
        if self.cert_url is not None:
            json['certUrl'] = self.cert_url
        if self.cert_sha256 is not None:
            json['certSha256'] = self.cert_sha256
        if self.certificates is not None:
            json['certificates'] = [i for i in self.certificates]
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> 'SignedExchangeSignature':
        cert_url = json['certUrl'] if 'certUrl' in json else None
        cert_sha256 = json['certSha256'] if 'certSha256' in json else None
        certificates = [i for i in json['certificates']] if 'certificates' in json else None
        return cls(
            label=json['label'],
            signature=json['signature'],
            integrity=json['integrity'],
            cert_url=cert_url,
            cert_sha256=cert_sha256,
            validity_url=json['validityUrl'],
            date=json['date'],
            expires=json['expires'],
            certificates=certificates,
        )

@dataclass
class SignedExchangeHeader:
    '''
    Information about a signed exchange header.
    https://wicg.github.io/webpackage/draft-yasskin-httpbis-origin-signed-exchanges-impl.html#cbor-representation
    '''
    #: Signed exchange request URL.
    request_url: str

    #: Signed exchange response code.
    response_code: int

    #: Signed exchange response headers.
    response_headers: Headers

    #: Signed exchange response signature.
    signatures: typing.List['SignedExchangeSignature']

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {
            'requestUrl': self.request_url,
            'responseCode': self.response_code,
            'responseHeaders': self.response_headers.to_json(),
            'signatures': [i.to_json() for i in self.signatures],
        }
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> 'SignedExchangeHeader':
        return cls(
            request_url=json['requestUrl'],
            response_code=json['responseCode'],
            response_headers=Headers.from_json(json['responseHeaders']),
            signatures=[SignedExchangeSignature.from_json(i) for i in json['signatures']],
        )

@dataclass
class SignedExchangeError:
    '''
    Information about a signed exchange response.
    '''
    #: Error message.
    message: str

    #: The index of the signature which caused the error.
    signature_index: typing.Optional[int] = None

    #: The field which caused the error.
    error_field: typing.Optional[SignedExchangeErrorField] = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {
            'message': self.message,
        }
        if self.signature_index is not None:
            json['signatureIndex'] = self.signature_index
        if self.error_field is not None:
            json['errorField'] = self.error_field.to_json()
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> 'SignedExchangeError':
        signature_index = json['signatureIndex'] if 'signatureIndex' in json else None
        error_field = SignedExchangeErrorField.from_json(json['errorField']) if 'errorField' in json else None
        return cls(
            message=json['message'],
            signature_index=signature_index,
            error_field=error_field,
        )

@dataclass
class SignedExchangeInfo:
    '''
    Information about a signed exchange response.
    '''
    #: The outer response of signed HTTP exchange which was received from network.
    outer_response: Response

    #: Information about the signed exchange header.
    header: typing.Optional[SignedExchangeHeader] = None

    #: Security details for the signed exchange header.
    security_details: typing.Optional[SecurityDetails] = None

    #: Errors occurred while handling the signed exchagne.
    errors: typing.Optional[typing.List['SignedExchangeError']] = None

    def to_json(self) -> T_JSON_DICT:
        json: T_JSON_DICT = {
            'outerResponse': self.outer_response.to_json(),
        }
        if self.header is not None:
            json['header'] = self.header.to_json()
        if self.security_details is not None:
            json['securityDetails'] = self.security_details.to_json()
        if self.errors is not None:
            json['errors'] = [i.to_json() for i in self.errors]
        return json

    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> 'SignedExchangeInfo':
        header = SignedExchangeHeader.from_json(json['header']) if 'header' in json else None
        security_details = SecurityDetails.from_json(json['securityDetails']) if 'securityDetails' in json else None
        errors = [SignedExchangeError.from_json(i) for i in json['errors']] if 'errors' in json else None
        return cls(
            outer_response=Response.from_json(json['outerResponse']),
            header=header,
            security_details=security_details,
            errors=errors,
        )

