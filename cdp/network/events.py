'''
DO NOT EDIT THIS FILE

This file is generated from the CDP definitions. If you need to make changes,
edit the generator and regenerate all of the modules.

Domain: network
Experimental: False
'''

from cdp.util import T_JSON_DICT
from dataclasses import dataclass
import enum
import typing

from .types import *
from ..page import types as page



@dataclass
class DataReceived:
    '''
    Fired when data chunk was received over the network.
    '''
    #: Fired when data chunk was received over the network.
    request_id: RequestId

    #: Fired when data chunk was received over the network.
    timestamp: MonotonicTime

    #: Fired when data chunk was received over the network.
    data_length: int

    #: Fired when data chunk was received over the network.
    encoded_data_length: int

    # These fields are used for internal purposes and are not part of CDP
    _domain = 'Network'
    _method = 'dataReceived'

    @classmethod
    def from_json(cls, json: dict) -> 'DataReceived':
        return cls(
            request_id=RequestId.from_json(json['requestId']),
            timestamp=MonotonicTime.from_json(json['timestamp']),
            data_length=int(json['dataLength']),
            encoded_data_length=int(json['encodedDataLength']),
        )


@dataclass
class EventSourceMessageReceived:
    '''
    Fired when EventSource message is received.
    '''
    #: Fired when EventSource message is received.
    request_id: RequestId

    #: Fired when EventSource message is received.
    timestamp: MonotonicTime

    #: Fired when EventSource message is received.
    event_name: str

    #: Fired when EventSource message is received.
    event_id: str

    #: Fired when EventSource message is received.
    data: str

    # These fields are used for internal purposes and are not part of CDP
    _domain = 'Network'
    _method = 'eventSourceMessageReceived'

    @classmethod
    def from_json(cls, json: dict) -> 'EventSourceMessageReceived':
        return cls(
            request_id=RequestId.from_json(json['requestId']),
            timestamp=MonotonicTime.from_json(json['timestamp']),
            event_name=str(json['eventName']),
            event_id=str(json['eventId']),
            data=str(json['data']),
        )


@dataclass
class LoadingFailed:
    '''
    Fired when HTTP request has failed to load.
    '''
    #: Fired when HTTP request has failed to load.
    request_id: RequestId

    #: Fired when HTTP request has failed to load.
    timestamp: MonotonicTime

    #: Fired when HTTP request has failed to load.
    type: ResourceType

    #: Fired when HTTP request has failed to load.
    error_text: str

    #: Fired when HTTP request has failed to load.
    canceled: typing.Optional[bool] = None

    #: Fired when HTTP request has failed to load.
    blocked_reason: typing.Optional[BlockedReason] = None

    # These fields are used for internal purposes and are not part of CDP
    _domain = 'Network'
    _method = 'loadingFailed'

    @classmethod
    def from_json(cls, json: dict) -> 'LoadingFailed':
        canceled = bool(json['canceled']) if 'canceled' in json else None
        blocked_reason = BlockedReason.from_json(json['blockedReason']) if 'blockedReason' in json else None
        return cls(
            request_id=RequestId.from_json(json['requestId']),
            timestamp=MonotonicTime.from_json(json['timestamp']),
            type=ResourceType.from_json(json['type']),
            error_text=str(json['errorText']),
            canceled=canceled,
            blocked_reason=blocked_reason,
        )


@dataclass
class LoadingFinished:
    '''
    Fired when HTTP request has finished loading.
    '''
    #: Fired when HTTP request has finished loading.
    request_id: RequestId

    #: Fired when HTTP request has finished loading.
    timestamp: MonotonicTime

    #: Fired when HTTP request has finished loading.
    encoded_data_length: float

    #: Fired when HTTP request has finished loading.
    should_report_corb_blocking: typing.Optional[bool] = None

    # These fields are used for internal purposes and are not part of CDP
    _domain = 'Network'
    _method = 'loadingFinished'

    @classmethod
    def from_json(cls, json: dict) -> 'LoadingFinished':
        should_report_corb_blocking = bool(json['shouldReportCorbBlocking']) if 'shouldReportCorbBlocking' in json else None
        return cls(
            request_id=RequestId.from_json(json['requestId']),
            timestamp=MonotonicTime.from_json(json['timestamp']),
            encoded_data_length=float(json['encodedDataLength']),
            should_report_corb_blocking=should_report_corb_blocking,
        )


@dataclass
class RequestIntercepted:
    '''
    Details of an intercepted HTTP request, which must be either allowed, blocked, modified or
    mocked.
    '''
    #: Details of an intercepted HTTP request, which must be either allowed, blocked, modified or
    #: mocked.
    interception_id: InterceptionId

    #: Details of an intercepted HTTP request, which must be either allowed, blocked, modified or
    #: mocked.
    request: Request

    #: Details of an intercepted HTTP request, which must be either allowed, blocked, modified or
    #: mocked.
    frame_id: page.FrameId

    #: Details of an intercepted HTTP request, which must be either allowed, blocked, modified or
    #: mocked.
    resource_type: ResourceType

    #: Details of an intercepted HTTP request, which must be either allowed, blocked, modified or
    #: mocked.
    is_navigation_request: bool

    #: Details of an intercepted HTTP request, which must be either allowed, blocked, modified or
    #: mocked.
    is_download: typing.Optional[bool] = None

    #: Details of an intercepted HTTP request, which must be either allowed, blocked, modified or
    #: mocked.
    redirect_url: typing.Optional[str] = None

    #: Details of an intercepted HTTP request, which must be either allowed, blocked, modified or
    #: mocked.
    auth_challenge: typing.Optional[AuthChallenge] = None

    #: Details of an intercepted HTTP request, which must be either allowed, blocked, modified or
    #: mocked.
    response_error_reason: typing.Optional[ErrorReason] = None

    #: Details of an intercepted HTTP request, which must be either allowed, blocked, modified or
    #: mocked.
    response_status_code: typing.Optional[int] = None

    #: Details of an intercepted HTTP request, which must be either allowed, blocked, modified or
    #: mocked.
    response_headers: typing.Optional[Headers] = None

    #: Details of an intercepted HTTP request, which must be either allowed, blocked, modified or
    #: mocked.
    request_id: typing.Optional[RequestId] = None

    # These fields are used for internal purposes and are not part of CDP
    _domain = 'Network'
    _method = 'requestIntercepted'

    @classmethod
    def from_json(cls, json: dict) -> 'RequestIntercepted':
        is_download = bool(json['isDownload']) if 'isDownload' in json else None
        redirect_url = str(json['redirectUrl']) if 'redirectUrl' in json else None
        auth_challenge = AuthChallenge.from_json(json['authChallenge']) if 'authChallenge' in json else None
        response_error_reason = ErrorReason.from_json(json['responseErrorReason']) if 'responseErrorReason' in json else None
        response_status_code = int(json['responseStatusCode']) if 'responseStatusCode' in json else None
        response_headers = Headers.from_json(json['responseHeaders']) if 'responseHeaders' in json else None
        request_id = RequestId.from_json(json['requestId']) if 'requestId' in json else None
        return cls(
            interception_id=InterceptionId.from_json(json['interceptionId']),
            request=Request.from_json(json['request']),
            frame_id=page.FrameId.from_json(json['frameId']),
            resource_type=ResourceType.from_json(json['resourceType']),
            is_navigation_request=bool(json['isNavigationRequest']),
            is_download=is_download,
            redirect_url=redirect_url,
            auth_challenge=auth_challenge,
            response_error_reason=response_error_reason,
            response_status_code=response_status_code,
            response_headers=response_headers,
            request_id=request_id,
        )


@dataclass
class RequestServedFromCache:
    '''
    Fired if request ended up loading from cache.
    '''
    #: Fired if request ended up loading from cache.
    request_id: RequestId

    # These fields are used for internal purposes and are not part of CDP
    _domain = 'Network'
    _method = 'requestServedFromCache'

    @classmethod
    def from_json(cls, json: dict) -> 'RequestServedFromCache':
        return cls(
            request_id=RequestId.from_json(json['requestId']),
        )


@dataclass
class RequestWillBeSent:
    '''
    Fired when page is about to send HTTP request.
    '''
    #: Fired when page is about to send HTTP request.
    request_id: RequestId

    #: Fired when page is about to send HTTP request.
    loader_id: LoaderId

    #: Fired when page is about to send HTTP request.
    document_url: str

    #: Fired when page is about to send HTTP request.
    request: Request

    #: Fired when page is about to send HTTP request.
    timestamp: MonotonicTime

    #: Fired when page is about to send HTTP request.
    wall_time: TimeSinceEpoch

    #: Fired when page is about to send HTTP request.
    initiator: Initiator

    #: Fired when page is about to send HTTP request.
    redirect_response: typing.Optional[Response] = None

    #: Fired when page is about to send HTTP request.
    type: typing.Optional[ResourceType] = None

    #: Fired when page is about to send HTTP request.
    frame_id: typing.Optional[page.FrameId] = None

    #: Fired when page is about to send HTTP request.
    has_user_gesture: typing.Optional[bool] = None

    # These fields are used for internal purposes and are not part of CDP
    _domain = 'Network'
    _method = 'requestWillBeSent'

    @classmethod
    def from_json(cls, json: dict) -> 'RequestWillBeSent':
        redirect_response = Response.from_json(json['redirectResponse']) if 'redirectResponse' in json else None
        type = ResourceType.from_json(json['type']) if 'type' in json else None
        frame_id = page.FrameId.from_json(json['frameId']) if 'frameId' in json else None
        has_user_gesture = bool(json['hasUserGesture']) if 'hasUserGesture' in json else None
        return cls(
            request_id=RequestId.from_json(json['requestId']),
            loader_id=LoaderId.from_json(json['loaderId']),
            document_url=str(json['documentURL']),
            request=Request.from_json(json['request']),
            timestamp=MonotonicTime.from_json(json['timestamp']),
            wall_time=TimeSinceEpoch.from_json(json['wallTime']),
            initiator=Initiator.from_json(json['initiator']),
            redirect_response=redirect_response,
            type=type,
            frame_id=frame_id,
            has_user_gesture=has_user_gesture,
        )


@dataclass
class ResourceChangedPriority:
    '''
    Fired when resource loading priority is changed
    '''
    #: Fired when resource loading priority is changed
    request_id: RequestId

    #: Fired when resource loading priority is changed
    new_priority: ResourcePriority

    #: Fired when resource loading priority is changed
    timestamp: MonotonicTime

    # These fields are used for internal purposes and are not part of CDP
    _domain = 'Network'
    _method = 'resourceChangedPriority'

    @classmethod
    def from_json(cls, json: dict) -> 'ResourceChangedPriority':
        return cls(
            request_id=RequestId.from_json(json['requestId']),
            new_priority=ResourcePriority.from_json(json['newPriority']),
            timestamp=MonotonicTime.from_json(json['timestamp']),
        )


@dataclass
class SignedExchangeReceived:
    '''
    Fired when a signed exchange was received over the network
    '''
    #: Fired when a signed exchange was received over the network
    request_id: RequestId

    #: Fired when a signed exchange was received over the network
    info: SignedExchangeInfo

    # These fields are used for internal purposes and are not part of CDP
    _domain = 'Network'
    _method = 'signedExchangeReceived'

    @classmethod
    def from_json(cls, json: dict) -> 'SignedExchangeReceived':
        return cls(
            request_id=RequestId.from_json(json['requestId']),
            info=SignedExchangeInfo.from_json(json['info']),
        )


@dataclass
class ResponseReceived:
    '''
    Fired when HTTP response is available.
    '''
    #: Fired when HTTP response is available.
    request_id: RequestId

    #: Fired when HTTP response is available.
    loader_id: LoaderId

    #: Fired when HTTP response is available.
    timestamp: MonotonicTime

    #: Fired when HTTP response is available.
    type: ResourceType

    #: Fired when HTTP response is available.
    response: Response

    #: Fired when HTTP response is available.
    frame_id: typing.Optional[page.FrameId] = None

    # These fields are used for internal purposes and are not part of CDP
    _domain = 'Network'
    _method = 'responseReceived'

    @classmethod
    def from_json(cls, json: dict) -> 'ResponseReceived':
        frame_id = page.FrameId.from_json(json['frameId']) if 'frameId' in json else None
        return cls(
            request_id=RequestId.from_json(json['requestId']),
            loader_id=LoaderId.from_json(json['loaderId']),
            timestamp=MonotonicTime.from_json(json['timestamp']),
            type=ResourceType.from_json(json['type']),
            response=Response.from_json(json['response']),
            frame_id=frame_id,
        )


@dataclass
class WebSocketClosed:
    '''
    Fired when WebSocket is closed.
    '''
    #: Fired when WebSocket is closed.
    request_id: RequestId

    #: Fired when WebSocket is closed.
    timestamp: MonotonicTime

    # These fields are used for internal purposes and are not part of CDP
    _domain = 'Network'
    _method = 'webSocketClosed'

    @classmethod
    def from_json(cls, json: dict) -> 'WebSocketClosed':
        return cls(
            request_id=RequestId.from_json(json['requestId']),
            timestamp=MonotonicTime.from_json(json['timestamp']),
        )


@dataclass
class WebSocketCreated:
    '''
    Fired upon WebSocket creation.
    '''
    #: Fired upon WebSocket creation.
    request_id: RequestId

    #: Fired upon WebSocket creation.
    url: str

    #: Fired upon WebSocket creation.
    initiator: typing.Optional[Initiator] = None

    # These fields are used for internal purposes and are not part of CDP
    _domain = 'Network'
    _method = 'webSocketCreated'

    @classmethod
    def from_json(cls, json: dict) -> 'WebSocketCreated':
        initiator = Initiator.from_json(json['initiator']) if 'initiator' in json else None
        return cls(
            request_id=RequestId.from_json(json['requestId']),
            url=str(json['url']),
            initiator=initiator,
        )


@dataclass
class WebSocketFrameError:
    '''
    Fired when WebSocket message error occurs.
    '''
    #: Fired when WebSocket message error occurs.
    request_id: RequestId

    #: Fired when WebSocket message error occurs.
    timestamp: MonotonicTime

    #: Fired when WebSocket message error occurs.
    error_message: str

    # These fields are used for internal purposes and are not part of CDP
    _domain = 'Network'
    _method = 'webSocketFrameError'

    @classmethod
    def from_json(cls, json: dict) -> 'WebSocketFrameError':
        return cls(
            request_id=RequestId.from_json(json['requestId']),
            timestamp=MonotonicTime.from_json(json['timestamp']),
            error_message=str(json['errorMessage']),
        )


@dataclass
class WebSocketFrameReceived:
    '''
    Fired when WebSocket message is received.
    '''
    #: Fired when WebSocket message is received.
    request_id: RequestId

    #: Fired when WebSocket message is received.
    timestamp: MonotonicTime

    #: Fired when WebSocket message is received.
    response: WebSocketFrame

    # These fields are used for internal purposes and are not part of CDP
    _domain = 'Network'
    _method = 'webSocketFrameReceived'

    @classmethod
    def from_json(cls, json: dict) -> 'WebSocketFrameReceived':
        return cls(
            request_id=RequestId.from_json(json['requestId']),
            timestamp=MonotonicTime.from_json(json['timestamp']),
            response=WebSocketFrame.from_json(json['response']),
        )


@dataclass
class WebSocketFrameSent:
    '''
    Fired when WebSocket message is sent.
    '''
    #: Fired when WebSocket message is sent.
    request_id: RequestId

    #: Fired when WebSocket message is sent.
    timestamp: MonotonicTime

    #: Fired when WebSocket message is sent.
    response: WebSocketFrame

    # These fields are used for internal purposes and are not part of CDP
    _domain = 'Network'
    _method = 'webSocketFrameSent'

    @classmethod
    def from_json(cls, json: dict) -> 'WebSocketFrameSent':
        return cls(
            request_id=RequestId.from_json(json['requestId']),
            timestamp=MonotonicTime.from_json(json['timestamp']),
            response=WebSocketFrame.from_json(json['response']),
        )


@dataclass
class WebSocketHandshakeResponseReceived:
    '''
    Fired when WebSocket handshake response becomes available.
    '''
    #: Fired when WebSocket handshake response becomes available.
    request_id: RequestId

    #: Fired when WebSocket handshake response becomes available.
    timestamp: MonotonicTime

    #: Fired when WebSocket handshake response becomes available.
    response: WebSocketResponse

    # These fields are used for internal purposes and are not part of CDP
    _domain = 'Network'
    _method = 'webSocketHandshakeResponseReceived'

    @classmethod
    def from_json(cls, json: dict) -> 'WebSocketHandshakeResponseReceived':
        return cls(
            request_id=RequestId.from_json(json['requestId']),
            timestamp=MonotonicTime.from_json(json['timestamp']),
            response=WebSocketResponse.from_json(json['response']),
        )


@dataclass
class WebSocketWillSendHandshakeRequest:
    '''
    Fired when WebSocket is about to initiate handshake.
    '''
    #: Fired when WebSocket is about to initiate handshake.
    request_id: RequestId

    #: Fired when WebSocket is about to initiate handshake.
    timestamp: MonotonicTime

    #: Fired when WebSocket is about to initiate handshake.
    wall_time: TimeSinceEpoch

    #: Fired when WebSocket is about to initiate handshake.
    request: WebSocketRequest

    # These fields are used for internal purposes and are not part of CDP
    _domain = 'Network'
    _method = 'webSocketWillSendHandshakeRequest'

    @classmethod
    def from_json(cls, json: dict) -> 'WebSocketWillSendHandshakeRequest':
        return cls(
            request_id=RequestId.from_json(json['requestId']),
            timestamp=MonotonicTime.from_json(json['timestamp']),
            wall_time=TimeSinceEpoch.from_json(json['wallTime']),
            request=WebSocketRequest.from_json(json['request']),
        )

