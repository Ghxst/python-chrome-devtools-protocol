'''
DO NOT EDIT THIS FILE

This file is generated from the CDP definitions. If you need to make changes,
edit the generator and regenerate all of the modules.

Domain: network
Experimental: False
'''

from cdp.util import T_JSON_DICT
from dataclasses import dataclass
import enum
import typing

from .types import *
from ..page import types as page



@dataclass
class DataReceived:
    '''
    Fired when data chunk was received over the network.
    '''
    #: Fired when data chunk was received over the network.
    request_id: RequestId

    #: Fired when data chunk was received over the network.
    timestamp: MonotonicTime

    #: Fired when data chunk was received over the network.
    data_length: int

    #: Fired when data chunk was received over the network.
    encoded_data_length: int

    # These fields are used for internal purposes and are not part of CDP
    _domain = 'Network'
    _method = 'dataReceived'

    @classmethod
    def from_json(cls, json: dict) -> 'DataReceived':
        return cls(
            request_id=RequestId.from_json(json['requestId']),
            timestamp=MonotonicTime.from_json(json['timestamp']),
            data_length=int(json['dataLength']),
            encoded_data_length=int(json['encodedDataLength']),
        )


@dataclass
class EventSourceMessageReceived:
    '''
    Fired when EventSource message is received.
    '''
    #: Fired when EventSource message is received.
    request_id: RequestId

    #: Fired when EventSource message is received.
    timestamp: MonotonicTime

    #: Fired when EventSource message is received.
    event_name: str

    #: Fired when EventSource message is received.
    event_id: str

    #: Fired when EventSource message is received.
    data: str

    # These fields are used for internal purposes and are not part of CDP
    _domain = 'Network'
    _method = 'eventSourceMessageReceived'

    @classmethod
    def from_json(cls, json: dict) -> 'EventSourceMessageReceived':
        return cls(
            request_id=RequestId.from_json(json['requestId']),
            timestamp=MonotonicTime.from_json(json['timestamp']),
            event_name=str(json['eventName']),
            event_id=str(json['eventId']),
            data=str(json['data']),
        )


@dataclass
class LoadingFailed:
    '''
    Fired when HTTP request has failed to load.
    '''
    #: Fired when HTTP request has failed to load.
    request_id: RequestId

    #: Fired when HTTP request has failed to load.
    timestamp: MonotonicTime

    #: Fired when HTTP request has failed to load.
    type: ResourceType

    #: Fired when HTTP request has failed to load.
    error_text: str

    #: Fired when HTTP request has failed to load.
    canceled: bool

    #: Fired when HTTP request has failed to load.
    blocked_reason: BlockedReason

    # These fields are used for internal purposes and are not part of CDP
    _domain = 'Network'
    _method = 'loadingFailed'

    @classmethod
    def from_json(cls, json: dict) -> 'LoadingFailed':
        return cls(
            request_id=RequestId.from_json(json['requestId']),
            timestamp=MonotonicTime.from_json(json['timestamp']),
            type=ResourceType.from_json(json['type']),
            error_text=str(json['errorText']),
            canceled=bool(json['canceled']),
            blocked_reason=BlockedReason.from_json(json['blockedReason']),
        )


@dataclass
class LoadingFinished:
    '''
    Fired when HTTP request has finished loading.
    '''
    #: Fired when HTTP request has finished loading.
    request_id: RequestId

    #: Fired when HTTP request has finished loading.
    timestamp: MonotonicTime

    #: Fired when HTTP request has finished loading.
    encoded_data_length: float

    #: Fired when HTTP request has finished loading.
    should_report_corb_blocking: bool

    # These fields are used for internal purposes and are not part of CDP
    _domain = 'Network'
    _method = 'loadingFinished'

    @classmethod
    def from_json(cls, json: dict) -> 'LoadingFinished':
        return cls(
            request_id=RequestId.from_json(json['requestId']),
            timestamp=MonotonicTime.from_json(json['timestamp']),
            encoded_data_length=float(json['encodedDataLength']),
            should_report_corb_blocking=bool(json['shouldReportCorbBlocking']),
        )


@dataclass
class RequestIntercepted:
    '''
    Details of an intercepted HTTP request, which must be either allowed, blocked, modified or
    mocked.
    '''
    #: Details of an intercepted HTTP request, which must be either allowed, blocked, modified or
    #: mocked.
    interception_id: InterceptionId

    #: Details of an intercepted HTTP request, which must be either allowed, blocked, modified or
    #: mocked.
    request: Request

    #: Details of an intercepted HTTP request, which must be either allowed, blocked, modified or
    #: mocked.
    frame_id: page.FrameId

    #: Details of an intercepted HTTP request, which must be either allowed, blocked, modified or
    #: mocked.
    resource_type: ResourceType

    #: Details of an intercepted HTTP request, which must be either allowed, blocked, modified or
    #: mocked.
    is_navigation_request: bool

    #: Details of an intercepted HTTP request, which must be either allowed, blocked, modified or
    #: mocked.
    is_download: bool

    #: Details of an intercepted HTTP request, which must be either allowed, blocked, modified or
    #: mocked.
    redirect_url: str

    #: Details of an intercepted HTTP request, which must be either allowed, blocked, modified or
    #: mocked.
    auth_challenge: AuthChallenge

    #: Details of an intercepted HTTP request, which must be either allowed, blocked, modified or
    #: mocked.
    response_error_reason: ErrorReason

    #: Details of an intercepted HTTP request, which must be either allowed, blocked, modified or
    #: mocked.
    response_status_code: int

    #: Details of an intercepted HTTP request, which must be either allowed, blocked, modified or
    #: mocked.
    response_headers: Headers

    #: Details of an intercepted HTTP request, which must be either allowed, blocked, modified or
    #: mocked.
    request_id: RequestId

    # These fields are used for internal purposes and are not part of CDP
    _domain = 'Network'
    _method = 'requestIntercepted'

    @classmethod
    def from_json(cls, json: dict) -> 'RequestIntercepted':
        return cls(
            interception_id=InterceptionId.from_json(json['interceptionId']),
            request=Request.from_json(json['request']),
            frame_id=page.FrameId.from_json(json['frameId']),
            resource_type=ResourceType.from_json(json['resourceType']),
            is_navigation_request=bool(json['isNavigationRequest']),
            is_download=bool(json['isDownload']),
            redirect_url=str(json['redirectUrl']),
            auth_challenge=AuthChallenge.from_json(json['authChallenge']),
            response_error_reason=ErrorReason.from_json(json['responseErrorReason']),
            response_status_code=int(json['responseStatusCode']),
            response_headers=Headers.from_json(json['responseHeaders']),
            request_id=RequestId.from_json(json['requestId']),
        )


@dataclass
class RequestServedFromCache:
    '''
    Fired if request ended up loading from cache.
    '''
    #: Fired if request ended up loading from cache.
    request_id: RequestId

    # These fields are used for internal purposes and are not part of CDP
    _domain = 'Network'
    _method = 'requestServedFromCache'

    @classmethod
    def from_json(cls, json: dict) -> 'RequestServedFromCache':
        return cls(
            request_id=RequestId.from_json(json['requestId']),
        )


@dataclass
class RequestWillBeSent:
    '''
    Fired when page is about to send HTTP request.
    '''
    #: Fired when page is about to send HTTP request.
    request_id: RequestId

    #: Fired when page is about to send HTTP request.
    loader_id: LoaderId

    #: Fired when page is about to send HTTP request.
    document_url: str

    #: Fired when page is about to send HTTP request.
    request: Request

    #: Fired when page is about to send HTTP request.
    timestamp: MonotonicTime

    #: Fired when page is about to send HTTP request.
    wall_time: TimeSinceEpoch

    #: Fired when page is about to send HTTP request.
    initiator: Initiator

    #: Fired when page is about to send HTTP request.
    redirect_response: Response

    #: Fired when page is about to send HTTP request.
    type: ResourceType

    #: Fired when page is about to send HTTP request.
    frame_id: page.FrameId

    #: Fired when page is about to send HTTP request.
    has_user_gesture: bool

    # These fields are used for internal purposes and are not part of CDP
    _domain = 'Network'
    _method = 'requestWillBeSent'

    @classmethod
    def from_json(cls, json: dict) -> 'RequestWillBeSent':
        return cls(
            request_id=RequestId.from_json(json['requestId']),
            loader_id=LoaderId.from_json(json['loaderId']),
            document_url=str(json['documentURL']),
            request=Request.from_json(json['request']),
            timestamp=MonotonicTime.from_json(json['timestamp']),
            wall_time=TimeSinceEpoch.from_json(json['wallTime']),
            initiator=Initiator.from_json(json['initiator']),
            redirect_response=Response.from_json(json['redirectResponse']),
            type=ResourceType.from_json(json['type']),
            frame_id=page.FrameId.from_json(json['frameId']),
            has_user_gesture=bool(json['hasUserGesture']),
        )


@dataclass
class ResourceChangedPriority:
    '''
    Fired when resource loading priority is changed
    '''
    #: Fired when resource loading priority is changed
    request_id: RequestId

    #: Fired when resource loading priority is changed
    new_priority: ResourcePriority

    #: Fired when resource loading priority is changed
    timestamp: MonotonicTime

    # These fields are used for internal purposes and are not part of CDP
    _domain = 'Network'
    _method = 'resourceChangedPriority'

    @classmethod
    def from_json(cls, json: dict) -> 'ResourceChangedPriority':
        return cls(
            request_id=RequestId.from_json(json['requestId']),
            new_priority=ResourcePriority.from_json(json['newPriority']),
            timestamp=MonotonicTime.from_json(json['timestamp']),
        )


@dataclass
class SignedExchangeReceived:
    '''
    Fired when a signed exchange was received over the network
    '''
    #: Fired when a signed exchange was received over the network
    request_id: RequestId

    #: Fired when a signed exchange was received over the network
    info: SignedExchangeInfo

    # These fields are used for internal purposes and are not part of CDP
    _domain = 'Network'
    _method = 'signedExchangeReceived'

    @classmethod
    def from_json(cls, json: dict) -> 'SignedExchangeReceived':
        return cls(
            request_id=RequestId.from_json(json['requestId']),
            info=SignedExchangeInfo.from_json(json['info']),
        )


@dataclass
class ResponseReceived:
    '''
    Fired when HTTP response is available.
    '''
    #: Fired when HTTP response is available.
    request_id: RequestId

    #: Fired when HTTP response is available.
    loader_id: LoaderId

    #: Fired when HTTP response is available.
    timestamp: MonotonicTime

    #: Fired when HTTP response is available.
    type: ResourceType

    #: Fired when HTTP response is available.
    response: Response

    #: Fired when HTTP response is available.
    frame_id: page.FrameId

    # These fields are used for internal purposes and are not part of CDP
    _domain = 'Network'
    _method = 'responseReceived'

    @classmethod
    def from_json(cls, json: dict) -> 'ResponseReceived':
        return cls(
            request_id=RequestId.from_json(json['requestId']),
            loader_id=LoaderId.from_json(json['loaderId']),
            timestamp=MonotonicTime.from_json(json['timestamp']),
            type=ResourceType.from_json(json['type']),
            response=Response.from_json(json['response']),
            frame_id=page.FrameId.from_json(json['frameId']),
        )


@dataclass
class WebSocketClosed:
    '''
    Fired when WebSocket is closed.
    '''
    #: Fired when WebSocket is closed.
    request_id: RequestId

    #: Fired when WebSocket is closed.
    timestamp: MonotonicTime

    # These fields are used for internal purposes and are not part of CDP
    _domain = 'Network'
    _method = 'webSocketClosed'

    @classmethod
    def from_json(cls, json: dict) -> 'WebSocketClosed':
        return cls(
            request_id=RequestId.from_json(json['requestId']),
            timestamp=MonotonicTime.from_json(json['timestamp']),
        )


@dataclass
class WebSocketCreated:
    '''
    Fired upon WebSocket creation.
    '''
    #: Fired upon WebSocket creation.
    request_id: RequestId

    #: Fired upon WebSocket creation.
    url: str

    #: Fired upon WebSocket creation.
    initiator: Initiator

    # These fields are used for internal purposes and are not part of CDP
    _domain = 'Network'
    _method = 'webSocketCreated'

    @classmethod
    def from_json(cls, json: dict) -> 'WebSocketCreated':
        return cls(
            request_id=RequestId.from_json(json['requestId']),
            url=str(json['url']),
            initiator=Initiator.from_json(json['initiator']),
        )


@dataclass
class WebSocketFrameError:
    '''
    Fired when WebSocket message error occurs.
    '''
    #: Fired when WebSocket message error occurs.
    request_id: RequestId

    #: Fired when WebSocket message error occurs.
    timestamp: MonotonicTime

    #: Fired when WebSocket message error occurs.
    error_message: str

    # These fields are used for internal purposes and are not part of CDP
    _domain = 'Network'
    _method = 'webSocketFrameError'

    @classmethod
    def from_json(cls, json: dict) -> 'WebSocketFrameError':
        return cls(
            request_id=RequestId.from_json(json['requestId']),
            timestamp=MonotonicTime.from_json(json['timestamp']),
            error_message=str(json['errorMessage']),
        )


@dataclass
class WebSocketFrameReceived:
    '''
    Fired when WebSocket message is received.
    '''
    #: Fired when WebSocket message is received.
    request_id: RequestId

    #: Fired when WebSocket message is received.
    timestamp: MonotonicTime

    #: Fired when WebSocket message is received.
    response: WebSocketFrame

    # These fields are used for internal purposes and are not part of CDP
    _domain = 'Network'
    _method = 'webSocketFrameReceived'

    @classmethod
    def from_json(cls, json: dict) -> 'WebSocketFrameReceived':
        return cls(
            request_id=RequestId.from_json(json['requestId']),
            timestamp=MonotonicTime.from_json(json['timestamp']),
            response=WebSocketFrame.from_json(json['response']),
        )


@dataclass
class WebSocketFrameSent:
    '''
    Fired when WebSocket message is sent.
    '''
    #: Fired when WebSocket message is sent.
    request_id: RequestId

    #: Fired when WebSocket message is sent.
    timestamp: MonotonicTime

    #: Fired when WebSocket message is sent.
    response: WebSocketFrame

    # These fields are used for internal purposes and are not part of CDP
    _domain = 'Network'
    _method = 'webSocketFrameSent'

    @classmethod
    def from_json(cls, json: dict) -> 'WebSocketFrameSent':
        return cls(
            request_id=RequestId.from_json(json['requestId']),
            timestamp=MonotonicTime.from_json(json['timestamp']),
            response=WebSocketFrame.from_json(json['response']),
        )


@dataclass
class WebSocketHandshakeResponseReceived:
    '''
    Fired when WebSocket handshake response becomes available.
    '''
    #: Fired when WebSocket handshake response becomes available.
    request_id: RequestId

    #: Fired when WebSocket handshake response becomes available.
    timestamp: MonotonicTime

    #: Fired when WebSocket handshake response becomes available.
    response: WebSocketResponse

    # These fields are used for internal purposes and are not part of CDP
    _domain = 'Network'
    _method = 'webSocketHandshakeResponseReceived'

    @classmethod
    def from_json(cls, json: dict) -> 'WebSocketHandshakeResponseReceived':
        return cls(
            request_id=RequestId.from_json(json['requestId']),
            timestamp=MonotonicTime.from_json(json['timestamp']),
            response=WebSocketResponse.from_json(json['response']),
        )


@dataclass
class WebSocketWillSendHandshakeRequest:
    '''
    Fired when WebSocket is about to initiate handshake.
    '''
    #: Fired when WebSocket is about to initiate handshake.
    request_id: RequestId

    #: Fired when WebSocket is about to initiate handshake.
    timestamp: MonotonicTime

    #: Fired when WebSocket is about to initiate handshake.
    wall_time: TimeSinceEpoch

    #: Fired when WebSocket is about to initiate handshake.
    request: WebSocketRequest

    # These fields are used for internal purposes and are not part of CDP
    _domain = 'Network'
    _method = 'webSocketWillSendHandshakeRequest'

    @classmethod
    def from_json(cls, json: dict) -> 'WebSocketWillSendHandshakeRequest':
        return cls(
            request_id=RequestId.from_json(json['requestId']),
            timestamp=MonotonicTime.from_json(json['timestamp']),
            wall_time=TimeSinceEpoch.from_json(json['wallTime']),
            request=WebSocketRequest.from_json(json['request']),
        )

